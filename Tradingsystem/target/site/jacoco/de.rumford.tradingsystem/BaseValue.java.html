<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BaseValue.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tradingsystem</a> &gt; <a href="index.source.html" class="el_package">de.rumford.tradingsystem</a> &gt; <span class="el_source">BaseValue.java</span></div><h1>BaseValue.java</h1><pre class="source lang-java linenums">package de.rumford.tradingsystem;

import java.util.Arrays;

import org.apache.commons.lang3.ArrayUtils;

import de.rumford.tradingsystem.helper.GeneratedCode;
import de.rumford.tradingsystem.helper.Util;
import de.rumford.tradingsystem.helper.Validator;
import de.rumford.tradingsystem.helper.ValueDateTupel;

/**
 * The BaseValue is a substantial part for every trading system and
 * provides the values to be decided upon by the rules. It encapsulates the
 * underlying value, e.g. a stocks tracker, and represents its values as an
 * array of {@link ValueDateTupel}. This are guaranteed to be in ascending
 * order and free of duplicates.
 * &lt;p&gt;
 * Each BaseValue has two final static values that cannot be changed and
 * are deemed to preserve comparability of base values. The first such
 * value is the lookback window. It indicates the amount of values relevant
 * (enough) for standard deviation calculation. A lookback window of 25, as
 * implemented, deems all values &quot;older&quot; than 25 time intervals (as stated
 * by the given ValueDateTupels) irrelevant for standard deviation
 * calculation. As a matter of fact, these older values are still
 * considered in standard deviation calculation, but the factor they are
 * being multiplied with (due to the recursive calculation of the standard
 * deviation value) is being considered as too small to actually make a
 * noticable difference.
 * &lt;p&gt;
 * The second predefined value is the short index initial value. If no
 * array representing an adequate short index is given into the
 * constructor, an array of such values is calculated by subtracting the
 * returns (percentage wise) between two time intervals from the previous
 * short index value. The short index initial value simply marks the value
 * to be set for the first time interval. Its value does not play any role
 * in further calculations, as proportions will remain unaltered, no matter
 * the actual initial value.
 * 
 * @author Max Rumford
 *
 */
public class BaseValue {

  /* Factor used in the lookback window for standard deviation */
  private static final int LOOKBACK_WINDOW = 25;
  /* Starting value for the short index values if no values are provided */
  private static final double SHORT_INDEX_INITIAL_VALUE = 1000d;

  /* Name to identify an instance. Has no effect. */
  private String name;
  /* The values upon which the calculations shall take place. */
  private ValueDateTupel[] values;
  /*
   * An array of values representing the short index values to the given
   * values.
   */
  private ValueDateTupel[] shortIndexValues;
  /* An array of values representing the standard deviation values. */
  private ValueDateTupel[] standardDeviationValues;

  /**
   * Creates a new {@link BaseValue} instance using the passed
   * {@code String} for identification and stores the passed array of
   * {@link ValueDateTupel} as values. Short index values are calculated
   * based on the given values as specified in
   * {@link BaseValue#calculateShortIndexValues(ValueDateTupel[])}.
   * 
   * @param name   {@code String} Name used to identify the represented
   *               base value. Is not used for calculation of any kind.
   *               Must be of length greater than {@code 0}.
   * @param values {@code ValueDateTupel[]} Values of the represented base
   *               value. Must not be null. Must be of length greater than
   *               {@code 0}. Must be in an ascending order. Must not
   *               contain nulls. Must not contain values of Double.NaN.
   * @throws IllegalArgumentException if the input values are not within
   *                                  specification
   */
<span class="fc" id="L79">  public BaseValue(String name, ValueDateTupel[] values) {</span>
<span class="fc" id="L80">    validateInput(name, values);</span>

<span class="fc" id="L82">    this.setName(name);</span>
<span class="fc" id="L83">    this.setValues(values);</span>

<span class="fc" id="L85">    this.setShortIndexValues(calculateShortIndexValues(values));</span>
<span class="fc" id="L86">    this.setStandardDeviationValues(</span>
<span class="fc" id="L87">        calculateStandardDeviationValues(values));</span>
<span class="fc" id="L88">  }</span>

  /**
   * Creates a new {@link BaseValue} instance using the passed
   * {@code String} for identification and stores the passed array of
   * {@link ValueDateTupel} as values and the second passed array of
   * {@link ValueDateTupel} as shortIndexValues.
   * 
   * @param name             {@code String} Name used to identify the
   *                         represented base value. Fulfills no purpose
   *                         and is not used for calculation of any kind.
   *                         Must be of length greater than {@code 0}.
   * @param values           {@code ValueDateTupel[]} Values of the
   *                         represented base value. Must not be null. Must
   *                         be of length greater than {@code 0}. Must be
   *                         in an ascending order. Must not contain nulls.
   *                         Must not contain values of Double.NaN.
   * @param shortIndexValues {@code ValueDateTupel[]} Short index values of
   *                         the represented base value. Must not be null.
   *                         Must be of length greater than {@code 0}. Must
   *                         be in an ascending order. Must not contain
   *                         nulls. Must not contain values of Double.NaN.
   * @throws IllegalArgumentException if the input values are not within
   *                                  specification
   */
  public BaseValue(String name, ValueDateTupel[] values,
      ValueDateTupel[] shortIndexValues) {
<span class="fc" id="L115">    this(name, values);</span>

    try {
<span class="fc" id="L118">      Validator.validateValues(shortIndexValues);</span>
<span class="fc" id="L119">      Validator.validateDates(shortIndexValues);</span>
<span class="fc" id="L120">    } catch (Exception e) {</span>
<span class="fc" id="L121">      throw new IllegalArgumentException(</span>
          &quot;Given short index values do not meet the specifications.&quot;, e);
<span class="fc" id="L123">    }</span>

<span class="fc" id="L125">    ValueDateTupel[][] valuesAndShortIndexValues = { values,</span>
        shortIndexValues };

<span class="fc" id="L128">    ValueDateTupel[][] alignedValuesAndShortIndexValues = ValueDateTupel</span>
<span class="fc" id="L129">        .alignDates(valuesAndShortIndexValues);</span>
<span class="fc" id="L130">    this.setValues(alignedValuesAndShortIndexValues[0]);</span>
<span class="fc" id="L131">    this.setShortIndexValues(alignedValuesAndShortIndexValues[1]);</span>
<span class="fc" id="L132">  }</span>

  /**
   * Calculates the short index values corresponding with a list of given
   * values. The initial value is set to be {@code 1000}. The short index
   * decreases by the same percentage the base value increases. If the base
   * value increases by {@code 10%}, the short index decreases by
   * {@code 10%} and vice versa.
   * 
   * &lt;p&gt;
   * The short index value is calculated as follows:
   * {@code v_s,t = v_s,t-1 - v_s,t-1 *
   * return_t,t-1}. Variables:
   * &lt;/p&gt;
   * 
   * &lt;ul&gt;
   * &lt;li&gt;{@code v_s,t} = short value on time interval {@code t}&lt;/li&gt;
   * &lt;li&gt;{@code return_t,t-1} = returns in the base value between two
   * consecutive time intervals&lt;/li&gt;
   * &lt;/ul&gt;
   * 
   * &lt;p&gt;
   * If return of the base value exceeds 50% the return used to calculate
   * the short index value is floored to 50%.
   * 
   * @param values {@codeValueDateTupel[]} values to base the short index
   *               values on
   * @return {@code ValueDateTupel[]} array of short index values
   * @throws IllegalArgumentException if the passed values array contains
   *                                  no elements
   */
  private static ValueDateTupel[] calculateShortIndexValues(
      ValueDateTupel[] values) {
    /**
     * Declare the return value. There are always as many short index
     * values as there are base values.
     */
<span class="fc" id="L169">    ValueDateTupel[] calculatedShortIndexValues = ValueDateTupel</span>
<span class="fc" id="L170">        .createEmptyArray(values.length);</span>
<span class="fc" id="L171">    calculatedShortIndexValues[0] = new ValueDateTupel(values[0].getDate(),</span>
        SHORT_INDEX_INITIAL_VALUE);

    ValueDateTupel formerValue;
    ValueDateTupel latterValue;

    /**
     * Loop over the provided values array and calculate the corresponding
     * short index value for every time interval t &gt; 0.
     */
<span class="fc bfc" id="L181" title="All 2 branches covered.">    for (int i = 1; i &lt; values.length; i++) {</span>
<span class="fc" id="L182">      formerValue = values[i - 1];</span>
<span class="fc" id="L183">      latterValue = values[i];</span>

<span class="fc" id="L185">      double returnPercentagePoints = Util</span>
<span class="fc" id="L186">          .calculateReturn(formerValue.getValue(), latterValue.getValue());</span>

      /**
       * If the base value generates more than 50% in returns (and thus
       * decreasing the short index value by more than 50%) the return
       * percentage is set to 50%.
       */
<span class="fc bfc" id="L193" title="All 2 branches covered.">      if (returnPercentagePoints &gt; 0.5)</span>
<span class="fc" id="L194">        returnPercentagePoints = 0.5;</span>

<span class="fc" id="L196">      double shortIndexValue = calculatedShortIndexValues[i - 1].getValue()</span>
<span class="fc" id="L197">          - calculatedShortIndexValues[i - 1].getValue()</span>
              * returnPercentagePoints;

<span class="fc" id="L200">      calculatedShortIndexValues[i] = new ValueDateTupel(</span>
<span class="fc" id="L201">          latterValue.getDate(), shortIndexValue);</span>
    }

<span class="fc" id="L204">    return calculatedShortIndexValues;</span>
  }

  /**
   * Calculate the standard deviation values for the given base values. The
   * first value is always Double.NaN.
   * &lt;p&gt;
   * {@code sd = baseValue * sqrt[ EWMA( return^2 ) ]}
   * 
   * @param baseValues {@code ValueDateTupel[]} the given base values.
   * @return {@code ValueDateTupel[]} the calculated standard deviation
   *         values.
   */
  private static ValueDateTupel[] calculateStandardDeviationValues(
      ValueDateTupel[] baseValues) {

    /*
     * Initiate the squared returns. The first value is always Double.NaN
     */
<span class="fc" id="L223">    ValueDateTupel[] squaredReturns = {};</span>

    /* Calculate the squared returns */
<span class="fc bfc" id="L226" title="All 2 branches covered.">    for (int i = 0; i &lt; baseValues.length - 1; i++) {</span>
      double returns;
<span class="fc" id="L228">      returns = Util.calculateReturn(baseValues[i].getValue(),</span>
<span class="fc" id="L229">          baseValues[i + 1].getValue());</span>
<span class="fc" id="L230">      squaredReturns = ArrayUtils.add(squaredReturns, new ValueDateTupel(</span>
<span class="fc" id="L231">          baseValues[i + 1].getDate(), Math.pow(returns, 2)));</span>
    }

    /* Instantiate the EWMA used for the standard deviation. */
<span class="fc" id="L235">    EWMA ewmaOfStandardDeviation = new EWMA(squaredReturns,</span>
        LOOKBACK_WINDOW);

    /*
     * The first value is always Double.NaN, as the first value cannot have
     * standard deviation from itself.
     */
<span class="fc" id="L242">    ValueDateTupel[] standardDeviationValues = {};</span>

    /* Fill in the calculated values. */
<span class="fc bfc" id="L245" title="All 2 branches covered.">    for (int i = 0; i &lt; squaredReturns.length; i++) {</span>
<span class="fc" id="L246">      double squaredEwmaOfVolatility = ewmaOfStandardDeviation</span>
<span class="fc" id="L247">          .getEwmaValues()[i].getValue();</span>
<span class="fc" id="L248">      double ewmaOfVolatility = Math.sqrt(squaredEwmaOfVolatility);</span>
      /*
       * The base values array has one more value than the
       * standardDeviationValues will have, as there cannot be a standard
       * deviation value for the first time interval. The first base value
       * will not have a standard deviation value. Therefore to e.g.
       * calculate the _first_ sd value, the _second_ base value has to be
       * used.
       */
<span class="fc" id="L257">      double standardDeviation = ewmaOfVolatility</span>
<span class="fc" id="L258">          * baseValues[i + 1].getValue();</span>
<span class="fc" id="L259">      standardDeviationValues = ArrayUtils.add(standardDeviationValues,</span>
<span class="fc" id="L260">          new ValueDateTupel(baseValues[i + 1].getDate(),</span>
              standardDeviation));
    }

    /* Return the standard deviations. */
<span class="fc" id="L265">    return standardDeviationValues;</span>
  }

  /**
   * Validates the given parameters. Used by the Constructors to validate
   * the constructor parameters.
   * 
   * @param name   {@code String} Name to be set for a {@link BaseValue}.
   *               Must not be null. Must not have a length of {@code 0}.
   * @param values {@code ValueDateTupel[]} Values to be set for a
   *               {@link BaseValue}. Must pass
   *               {@link Validator#validateValues(ValueDateTupel[])} and
   *               {@link Validator#validateDates(ValueDateTupel[])}.
   * @throws IllegalArgumentException if one of the above specifications is
   *                                  not met.
   */
  private static void validateInput(String name, ValueDateTupel[] values) {
    /* Check if name is null */
<span class="fc bfc" id="L283" title="All 2 branches covered.">    if (name == null)</span>
<span class="fc" id="L284">      throw new IllegalArgumentException(</span>
          &quot;The given name must not be null&quot;);

    /* Check if name is not empty */
<span class="fc bfc" id="L288" title="All 2 branches covered.">    if (name.length() == 0)</span>
<span class="fc" id="L289">      throw new IllegalArgumentException(</span>
          &quot;Name must not be an empty String&quot;);

<span class="fc" id="L292">    Validator.validateValues(values);</span>
<span class="fc" id="L293">    Validator.validateDates(values);</span>
<span class="fc" id="L294">  }</span>

  /**
   * ======================================================================
   * OVERRIDES
   * ======================================================================
   */

  /**
   * A hash code for this base value
   */
  @GeneratedCode
  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + Arrays.hashCode(shortIndexValues);
    result = prime * result + Arrays.hashCode(values);
    return result;
  }

  /**
   * Checks if this base value is equal to another base value.
   */
  @GeneratedCode
  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    BaseValue other = (BaseValue) obj;
    if (name == null) {
      if (other.name != null)
        return false;
    } else if (!name.equals(other.name))
      return false;
    if (!Arrays.equals(shortIndexValues, other.shortIndexValues))
      return false;
    if (!Arrays.equals(values, other.values))
      return false;
    return true;
  }

  /**
   * Outputs the fields of this base value as a {@code String}.
   */
  @GeneratedCode
  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(&quot;BaseValue [name=&quot;);
    builder.append(name);
    builder.append(&quot;, values=&quot;);
    builder.append(Arrays.toString(values));
    builder.append(&quot;, shortIndexValues=&quot;);
    builder.append(Arrays.toString(shortIndexValues));
    builder.append(&quot;, standardDeviationValues=&quot;);
    builder.append(Arrays.toString(standardDeviationValues));
    builder.append(&quot;]&quot;);
    return builder.toString();
  }

  /**
   * ======================================================================
   * GETTERS AND SETTERS
   * ======================================================================
   */
  /**
   * Get the name of this {@link BaseValue}
   * 
   * @return name {@code String} of this {@link BaseValue}
   */
  public String getName() {
<span class="nc" id="L371">    return name;</span>
  }

  /**
   * Set the name of this {@link BaseValue}
   * 
   * @param name {@code String} the name to be set in this
   *             {@link BaseValue}
   */
  private void setName(String name) {
<span class="fc" id="L381">    this.name = name;</span>
<span class="fc" id="L382">  }</span>

  /**
   * Get the values of this {@link BaseValue}
   * 
   * @return values {@code ValueDateTupel[]} BaseValue
   */
  public ValueDateTupel[] getValues() {
<span class="fc" id="L390">    return values;</span>
  }

  /**
   * Set the values of this {@link BaseValue}
   * 
   * @param values {@code ValueDateTupel[]} the values to be set
   */
  private void setValues(ValueDateTupel[] values) {
<span class="fc" id="L399">    this.values = values;</span>
<span class="fc" id="L400">  }</span>

  /**
   * Get the shortIndexValues of this {@link BaseValue}
   * 
   * @return shortIndexValues {@code ValueDateTupel[]} shortIndexValues of
   *         this {@link BaseValue}
   */
  public ValueDateTupel[] getShortIndexValues() {
<span class="fc" id="L409">    return shortIndexValues;</span>
  }

  /**
   * Set the shortIndexValues of this {@link BaseValue}
   * 
   * @param shortIndexValues {@code ValueDateTupel[]} the shortIndexValues
   *                         to be set
   */
  private void setShortIndexValues(ValueDateTupel[] shortIndexValues) {
<span class="fc" id="L419">    this.shortIndexValues = shortIndexValues;</span>
<span class="fc" id="L420">  }</span>

  /**
   * Get the standard deviation values for this base value.
   * 
   * @return standardDeviationValues BaseValue
   */
  public ValueDateTupel[] getStandardDeviationValues() {
<span class="fc" id="L428">    return standardDeviationValues;</span>
  }

  /**
   * Set the standard deviation values for this base value.
   * 
   * @param standardDeviationValues the standardDeviationValues to set
   */
  private void setStandardDeviationValues(
      ValueDateTupel[] standardDeviationValues) {
<span class="fc" id="L438">    this.standardDeviationValues = standardDeviationValues;</span>
<span class="fc" id="L439">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
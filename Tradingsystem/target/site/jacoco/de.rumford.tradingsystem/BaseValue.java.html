<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BaseValue.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tradingsystem</a> &gt; <a href="index.source.html" class="el_package">de.rumford.tradingsystem</a> &gt; <span class="el_source">BaseValue.java</span></div><h1>BaseValue.java</h1><pre class="source lang-java linenums">package de.rumford.tradingsystem;

import java.util.Arrays;

import org.apache.commons.lang3.ArrayUtils;

import de.rumford.tradingsystem.helper.GeneratedCode;
import de.rumford.tradingsystem.helper.Util;
import de.rumford.tradingsystem.helper.Validator;
import de.rumford.tradingsystem.helper.ValueDateTupel;

/**
 * The BaseValue is a substantial part for every trading system and provides the values to be decided upon by the rules.
 * It encapsulates the underlying value, e.g. a stocks tracker, and represents its values as an array of
 * {@link ValueDateTupel}. This are guaranteed to be in ascending order and free of duplicates.
 * &lt;p&gt;
 * Each BaseValue has two final static values that cannot be changed and are deemed to preserve comparability of base
 * values. The first such value is the lookback window. It indicates the amount of values relevant (enough) for standard
 * deviation calculation. A lookback window of 25, as implemented, deems all values &quot;older&quot; than 25 time intervals (as
 * stated by the given ValueDateTupels) irrelevant for standard deviation calculation. As a matter of fact, these older
 * values are still considered in standard deviation calculation, but the factor they are being multiplied with (due to
 * the recursive calculation of the standard deviation value) is being considered as too small to actually make a
 * noticable difference.
 * &lt;p&gt;
 * The second predefined value is the short index initial value. If no array representing an adequate short index is
 * given into the constructor, an array of such values is calculated by subtracting the returns (percentage wise)
 * between two time intervals from the previous short index value. The short index initial value simply marks the value
 * to be set for the first time interval. Its value does not play any role in further calculations, as proportions will
 * remain unaltered, no matter the actual initial value.
 * 
 * @author Max Rumford
 */
public class BaseValue {

	/* Factor used in the lookback window for standard deviation */
	private static final int LOOKBACK_WINDOW = 25;
	/* Starting value for the short index values if no values are provided */
	private static final double SHORT_INDEX_INITIAL_VALUE = 1000d;

	/* Name to identify an instance. Has no effect. */
	private String name;
	/* The values upon which the calculations shall take place. */
	private ValueDateTupel[] values;
	/*
	 * An array of values representing the short index values to the given values.
	 */
	private ValueDateTupel[] shortIndexValues;
	/* An array of values representing the standard deviation values. */
	private ValueDateTupel[] standardDeviationValues;

	/**
	 * Creates a new {@link BaseValue} instance using the passed {@code String} for identification and stores the passed
	 * array of {@link ValueDateTupel} as values. Short index values are calculated based on the given values as
	 * specified in {@link BaseValue#calculateShortIndexValues(ValueDateTupel[])}.
	 * 
	 * @param  name                     {@code String} Name used to identify the represented base value. Is not used for
	 *                                  calculation of any kind. Must be of length greater than {@code 0}.
	 * @param  values                   {@code ValueDateTupel[]} Values of the represented base value. Must not be null.
	 *                                  Must be of length greater than {@code 0}. Must be in an ascending order. Must
	 *                                  not contain nulls. Must not contain values of Double.NaN.
	 * @throws IllegalArgumentException if the input values are not within specification
	 */
<span class="fc" id="L63">	public BaseValue(String name, ValueDateTupel[] values) {</span>
<span class="fc" id="L64">		validateInput(name, values);</span>

<span class="fc" id="L66">		this.setName(name);</span>
<span class="fc" id="L67">		this.setValues(values);</span>

<span class="fc" id="L69">		this.setShortIndexValues(calculateShortIndexValues(values));</span>
<span class="fc" id="L70">		this.setStandardDeviationValues(calculateStandardDeviationValues(values));</span>
<span class="fc" id="L71">	}</span>

	/**
	 * Creates a new {@link BaseValue} instance using the passed {@code String} for identification and stores the passed
	 * array of {@link ValueDateTupel} as values and the second passed array of {@link ValueDateTupel} as
	 * shortIndexValues.
	 * 
	 * @param  name                     {@code String} Name used to identify the represented base value. Fulfills no
	 *                                  purpose and is not used for calculation of any kind. Must be of length greater
	 *                                  than {@code 0}.
	 * @param  values                   {@code ValueDateTupel[]} Values of the represented base value. Must not be null.
	 *                                  Must be of length greater than {@code 0}. Must be in an ascending order. Must
	 *                                  not contain nulls. Must not contain values of Double.NaN.
	 * @param  shortIndexValues         {@code ValueDateTupel[]} Short index values of the represented base value. Must
	 *                                  not be null. Must be of length greater than {@code 0}. Must be in an ascending
	 *                                  order. Must not contain nulls. Must not contain values of Double.NaN.
	 * @throws IllegalArgumentException if the input values are not within specification
	 */
	public BaseValue(String name, ValueDateTupel[] values, ValueDateTupel[] shortIndexValues) {
<span class="fc" id="L90">		this(name, values);</span>

		try {
<span class="fc" id="L93">			Validator.validateValues(shortIndexValues);</span>
<span class="fc" id="L94">			Validator.validateDates(shortIndexValues);</span>
<span class="fc" id="L95">		} catch (Exception e) {</span>
<span class="fc" id="L96">			throw new IllegalArgumentException(&quot;Given short index values do not meet the specifications.&quot;, e);</span>
<span class="fc" id="L97">		}</span>

<span class="fc" id="L99">		ValueDateTupel[][] valuesAndShortIndexValues = { values, shortIndexValues };</span>

<span class="fc" id="L101">		ValueDateTupel[][] alignedValuesAndShortIndexValues = ValueDateTupel.alignDates(valuesAndShortIndexValues);</span>
<span class="fc" id="L102">		this.setValues(alignedValuesAndShortIndexValues[0]);</span>
<span class="fc" id="L103">		this.setShortIndexValues(alignedValuesAndShortIndexValues[1]);</span>
<span class="fc" id="L104">	}</span>

	/**
	 * Calculates the short index values corresponding with a list of given values. The initial value is set to be
	 * {@code 1000}. The short index decreases by the same percentage the base value increases. If the base value
	 * increases by {@code 10%}, the short index decreases by {@code 10%} and vice versa.
	 * &lt;p&gt;
	 * The short index value is calculated as follows: {@code v_s,t = v_s,t-1 - v_s,t-1 *
	 * return_t,t-1}. Variables:
	 * &lt;/p&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;{@code v_s,t} = short value on time interval {@code t}&lt;/li&gt;
	 * &lt;li&gt;{@code return_t,t-1} = returns in the base value between two consecutive time intervals&lt;/li&gt;
	 * &lt;/ul&gt;
	 * &lt;p&gt;
	 * If return of the base value exceeds 50% the return used to calculate the short index value is floored to 50%.
	 * 
	 * @param  values                   {@codeValueDateTupel[]} values to base the short index values on
	 * @return                          {@code ValueDateTupel[]} array of short index values
	 * @throws IllegalArgumentException if the passed values array contains no elements
	 */
	private static ValueDateTupel[] calculateShortIndexValues(ValueDateTupel[] values) {
		/**
		 * Declare the return value. There are always as many short index values as there are base values.
		 */
<span class="fc" id="L129">		ValueDateTupel[] calculatedShortIndexValues = ValueDateTupel.createEmptyArray(values.length);</span>
<span class="fc" id="L130">		calculatedShortIndexValues[0] = new ValueDateTupel(values[0].getDate(), SHORT_INDEX_INITIAL_VALUE);</span>

		ValueDateTupel formerValue;
		ValueDateTupel latterValue;

		/**
		 * Loop over the provided values array and calculate the corresponding short index value for every time interval
		 * t &gt; 0.
		 */
<span class="fc bfc" id="L139" title="All 2 branches covered.">		for (int i = 1; i &lt; values.length; i++) {</span>
<span class="fc" id="L140">			formerValue = values[i - 1];</span>
<span class="fc" id="L141">			latterValue = values[i];</span>

<span class="fc" id="L143">			double returnPercentagePoints = Util.calculateReturn(formerValue.getValue(), latterValue.getValue());</span>

			/**
			 * If the base value generates more than 50% in returns (and thus decreasing the short index value by more
			 * than 50%) the return percentage is set to 50%.
			 */
<span class="fc bfc" id="L149" title="All 2 branches covered.">			if (returnPercentagePoints &gt; 0.5)</span>
<span class="fc" id="L150">				returnPercentagePoints = 0.5;</span>

<span class="fc" id="L152">			double shortIndexValue = calculatedShortIndexValues[i - 1].getValue()</span>
<span class="fc" id="L153">			        - calculatedShortIndexValues[i - 1].getValue() * returnPercentagePoints;</span>

<span class="fc" id="L155">			calculatedShortIndexValues[i] = new ValueDateTupel(latterValue.getDate(), shortIndexValue);</span>
		}

<span class="fc" id="L158">		return calculatedShortIndexValues;</span>
	}

	/**
	 * Calculate the standard deviation values for the given base values. The first value is always Double.NaN.
	 * &lt;p&gt;
	 * {@code sd = baseValue * sqrt[ EWMA( return^2 ) ]}
	 * 
	 * @param  baseValues {@code ValueDateTupel[]} the given base values.
	 * @return            {@code ValueDateTupel[]} the calculated standard deviation values.
	 */
	private static ValueDateTupel[] calculateStandardDeviationValues(ValueDateTupel[] baseValues) {

		/*
		 * Initiate the squared returns. The first value is always Double.NaN
		 */
<span class="fc" id="L174">		ValueDateTupel[] squaredReturns = {};</span>

		/* Calculate the squared returns */
<span class="fc bfc" id="L177" title="All 2 branches covered.">		for (int i = 0; i &lt; baseValues.length - 1; i++) {</span>
			double returns;
<span class="fc" id="L179">			returns = Util.calculateReturn(baseValues[i].getValue(), baseValues[i + 1].getValue());</span>
<span class="fc" id="L180">			squaredReturns = ArrayUtils.add(squaredReturns,</span>
<span class="fc" id="L181">			        new ValueDateTupel(baseValues[i + 1].getDate(), Math.pow(returns, 2)));</span>
		}

		/* Instantiate the EWMA used for the standard deviation. */
<span class="fc" id="L185">		EWMA ewmaOfStandardDeviation = new EWMA(squaredReturns, LOOKBACK_WINDOW);</span>

		/*
		 * The first value is always Double.NaN, as the first value cannot have standard deviation from itself.
		 */
<span class="fc" id="L190">		ValueDateTupel[] standardDeviationValues = {};</span>

		/* Fill in the calculated values. */
<span class="fc bfc" id="L193" title="All 2 branches covered.">		for (int i = 0; i &lt; squaredReturns.length; i++) {</span>
<span class="fc" id="L194">			double squaredEwmaOfVolatility = ewmaOfStandardDeviation.getEwmaValues()[i].getValue();</span>
<span class="fc" id="L195">			double ewmaOfVolatility = Math.sqrt(squaredEwmaOfVolatility);</span>
			/*
			 * The base values array has one more value than the standardDeviationValues will have, as there cannot be a
			 * standard deviation value for the first time interval. The first base value will not have a standard
			 * deviation value. Therefore to e.g. calculate the _first_ sd value, the _second_ base value has to be
			 * used.
			 */
<span class="fc" id="L202">			double standardDeviation = ewmaOfVolatility * baseValues[i + 1].getValue();</span>
<span class="fc" id="L203">			standardDeviationValues = ArrayUtils.add(standardDeviationValues,</span>
<span class="fc" id="L204">			        new ValueDateTupel(baseValues[i + 1].getDate(), standardDeviation));</span>
		}

		/* Return the standard deviations. */
<span class="fc" id="L208">		return standardDeviationValues;</span>
	}

	/**
	 * Validates the given parameters. Used by the Constructors to validate the constructor parameters.
	 * 
	 * @param  name                     {@code String} Name to be set for a {@link BaseValue}. Must not be null. Must
	 *                                  not have a length of {@code 0}.
	 * @param  values                   {@code ValueDateTupel[]} Values to be set for a {@link BaseValue}. Must pass
	 *                                  {@link Validator#validateValues(ValueDateTupel[])} and
	 *                                  {@link Validator#validateDates(ValueDateTupel[])}.
	 * @throws IllegalArgumentException if one of the above specifications is not met.
	 */
	private static void validateInput(String name, ValueDateTupel[] values) {
		/* Check if name is null */
<span class="fc bfc" id="L223" title="All 2 branches covered.">		if (name == null)</span>
<span class="fc" id="L224">			throw new IllegalArgumentException(&quot;The given name must not be null&quot;);</span>

		/* Check if name is not empty */
<span class="fc bfc" id="L227" title="All 2 branches covered.">		if (name.length() == 0)</span>
<span class="fc" id="L228">			throw new IllegalArgumentException(&quot;Name must not be an empty String&quot;);</span>

<span class="fc" id="L230">		Validator.validateValues(values);</span>
<span class="fc" id="L231">		Validator.validateDates(values);</span>
<span class="fc" id="L232">	}</span>

	/**
	 * ====================================================================== OVERRIDES
	 * ======================================================================
	 */

	/**
	 * A hash code for this base value
	 */
	@GeneratedCode
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		result = prime * result + Arrays.hashCode(shortIndexValues);
		result = prime * result + Arrays.hashCode(values);
		return result;
	}

	/**
	 * Checks if this base value is equal to another base value.
	 */
	@GeneratedCode
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		BaseValue other = (BaseValue) obj;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		if (!Arrays.equals(shortIndexValues, other.shortIndexValues))
			return false;
		if (!Arrays.equals(values, other.values))
			return false;
		return true;
	}

	/**
	 * Outputs the fields of this base value as a {@code String}.
	 */
	@GeneratedCode
	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append(&quot;BaseValue [name=&quot;);
		builder.append(name);
		builder.append(&quot;, values=&quot;);
		builder.append(Arrays.toString(values));
		builder.append(&quot;, shortIndexValues=&quot;);
		builder.append(Arrays.toString(shortIndexValues));
		builder.append(&quot;, standardDeviationValues=&quot;);
		builder.append(Arrays.toString(standardDeviationValues));
		builder.append(&quot;]&quot;);
		return builder.toString();
	}

	/**
	 * ====================================================================== GETTERS AND SETTERS
	 * ======================================================================
	 */
	/**
	 * Get the name of this {@link BaseValue}
	 * 
	 * @return name {@code String} of this {@link BaseValue}
	 */
	public String getName() {
<span class="nc" id="L307">		return name;</span>
	}

	/**
	 * Set the name of this {@link BaseValue}
	 * 
	 * @param name {@code String} the name to be set in this {@link BaseValue}
	 */
	private void setName(String name) {
<span class="fc" id="L316">		this.name = name;</span>
<span class="fc" id="L317">	}</span>

	/**
	 * Get the values of this {@link BaseValue}
	 * 
	 * @return values {@code ValueDateTupel[]} BaseValue
	 */
	public ValueDateTupel[] getValues() {
<span class="fc" id="L325">		return values;</span>
	}

	/**
	 * Set the values of this {@link BaseValue}
	 * 
	 * @param values {@code ValueDateTupel[]} the values to be set
	 */
	private void setValues(ValueDateTupel[] values) {
<span class="fc" id="L334">		this.values = values;</span>
<span class="fc" id="L335">	}</span>

	/**
	 * Get the shortIndexValues of this {@link BaseValue}
	 * 
	 * @return shortIndexValues {@code ValueDateTupel[]} shortIndexValues of this {@link BaseValue}
	 */
	public ValueDateTupel[] getShortIndexValues() {
<span class="fc" id="L343">		return shortIndexValues;</span>
	}

	/**
	 * Set the shortIndexValues of this {@link BaseValue}
	 * 
	 * @param shortIndexValues {@code ValueDateTupel[]} the shortIndexValues to be set
	 */
	private void setShortIndexValues(ValueDateTupel[] shortIndexValues) {
<span class="fc" id="L352">		this.shortIndexValues = shortIndexValues;</span>
<span class="fc" id="L353">	}</span>

	/**
	 * Get the standard deviation values for this base value.
	 * 
	 * @return standardDeviationValues BaseValue
	 */
	public ValueDateTupel[] getStandardDeviationValues() {
<span class="fc" id="L361">		return standardDeviationValues;</span>
	}

	/**
	 * Set the standard deviation values for this base value.
	 * 
	 * @param standardDeviationValues the standardDeviationValues to set
	 */
	private void setStandardDeviationValues(ValueDateTupel[] standardDeviationValues) {
<span class="fc" id="L370">		this.standardDeviationValues = standardDeviationValues;</span>
<span class="fc" id="L371">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
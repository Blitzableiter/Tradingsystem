<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SubSystem.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tradingsystem</a> &gt; <a href="index.source.html" class="el_package">de.rumford.tradingsystem</a> &gt; <span class="el_source">SubSystem.java</span></div><h1>SubSystem.java</h1><pre class="source lang-java linenums">package de.rumford.tradingsystem;

import java.time.LocalDateTime;
import java.time.chrono.ChronoLocalDateTime;
import java.util.Arrays;

import org.apache.commons.lang3.ArrayUtils;

import de.rumford.tradingsystem.helper.GeneratedCode;
import de.rumford.tradingsystem.helper.Util;
import de.rumford.tradingsystem.helper.Validator;
import de.rumford.tradingsystem.helper.ValueDateTupel;

/**
 * The SubSystem is the most parental Structure in this library and
 * contains (directly or indirectly) all other (non-static) classes. It
 * combines rules and base values and is thus the only point to calculate
 * positions and perform backtesting of performance. By containing a
 * {@link DiversificationMultiplier} it copes with the diversity between
 * its rules and thus meets volatility target and scale.
 * 
 * @author Max Rumford
 *
 */
public class SubSystem {

  /*
   * The value to which the product prices shall be scaled to. Effect rises
   * if higher and capital goes lower.
   */
  private static final double PRICE_FACTOR_BASE_SCALE = 1;

  /* An Exception message. */
  private static final String MESSAGE_ILLEGAL_TEST_WINDOW = &quot;The given test window does not meet specifications.&quot;;

  /* The base value to use for performance calculation. */
  private BaseValue baseValue;
  /* The rules to be governed in this subsystem. */
  private Rule[] rules;
  /* The diversification multiplier for this subsystem. */
  private DiversificationMultiplier diversificationMultiplier;
  /* The starting capital used for performance calculation. */
  private double capital;
  /* The combined forecasts of all rules. */
  private ValueDateTupel[] combinedForecasts;
  /* The value all forecasts shall be scaled to. */
  private double baseScale;

  /**
   * Constructor for the SubSystem class.
   * 
   * @param baseValue {@link BaseValue} The base value to be used for all
   *                  the given rules' calculations. See
   *                  {@link #validateInput( BaseValue, Rule[], double, double)}
   *                  for limitations.
   * @param rules     {@code Rule[]} Array of {@link Rule} to be used for
   *                  forecast calculations in this SubSystem. See
   *                  {@link #validateInput( BaseValue, Rule[], double, double)}
   *                  for limitations.
   * @param capital   {@code double} The capital to be managed by this
   *                  SubSystem. See
   *                  {@link #validateInput( BaseValue, Rule[], double, double)}
   *                  for limitations.
   * @param baseScale {@code double} The base scale for this SubSystem's
   *                  forecasts. See
   *                  {@link #validateInput( BaseValue, Rule[], double, double)}
   *                  for limitations.
   */
  public SubSystem(BaseValue baseValue, Rule[] rules, double capital,
<span class="fc" id="L70">      double baseScale) {</span>

<span class="fc" id="L72">    validateInput(baseValue, rules, capital, baseScale);</span>

<span class="fc" id="L74">    validateRules(rules);</span>
<span class="fc" id="L75">    this.setRules(rules);</span>

<span class="fc" id="L77">    this.setBaseValue(baseValue);</span>
<span class="fc" id="L78">    this.setCapital(capital);</span>
<span class="fc" id="L79">    this.setBaseScale(baseScale);</span>
<span class="fc" id="L80">    this.setDiversificationMultiplier(</span>
        new DiversificationMultiplier(rules));
<span class="fc" id="L82">    this.setCombinedForecasts(this.calculateCombinedForecasts());</span>
<span class="fc" id="L83">  }</span>

  /**
   * Performs a backtest for the given parameters. Utilizes
   * {@link #calculatePerformanceValues(BaseValue, LocalDateTime, LocalDateTime, ValueDateTupel[], double, double)}
   * for actual performance calculation and returns performance value for
   * the last day.
   * 
   * @see SubSystem#calculatePerformanceValues(BaseValue, LocalDateTime,
   *      LocalDateTime, ValueDateTupel[], double, double)
   * 
   * @param baseValue         {@link BaseValue} The base value to be tested
   *                          against.
   * @param startOfTestWindow {@link LocalDateTime} First time interval of
   *                          test window.
   * @param endOfTestWindow   {@link LocalDateTime} Last time interval of
   *                          test window.
   * @param combinedForecasts {@code ValueDateTupel[]} The forecasts to be
   *                          used for performance calculation.
   * @param baseScale         {@code double} The value to which to scale
   *                          the forecasts to.
   * @param capital           {@code double} The starting capital.
   * @return {@code double} The performance value on the last day of the
   *         given test window.
   */
  public static double backtest(BaseValue baseValue,
      LocalDateTime startOfTestWindow, LocalDateTime endOfTestWindow,
      ValueDateTupel[] combinedForecasts, double baseScale,
      double capital) {

<span class="fc" id="L113">    ValueDateTupel[] performanceValues = calculatePerformanceValues(</span>
        baseValue, startOfTestWindow, endOfTestWindow, combinedForecasts,
        baseScale, capital);

<span class="fc" id="L117">    return performanceValues[performanceValues.length - 1].getValue();</span>
  }

  /**
   * Calls
   * {@link #calculatePerformanceValues(BaseValue, LocalDateTime, LocalDateTime, ValueDateTupel[], double, double)}
   * with instance properties.
   * 
   * @param startOfTestWindow {@link LocalDateTime} First time interval of
   *                          test window.
   * @param endOfTestWindow   {@link LocalDateTime} Last time interval of
   *                          test window.
   * @return {@code double} by way of
   *         {@link #backtest(BaseValue, LocalDateTime, LocalDateTime, ValueDateTupel[], double, double)}.
   */
  public double backtest(LocalDateTime startOfTestWindow,
      LocalDateTime endOfTestWindow) {
<span class="fc" id="L134">    return SubSystem.backtest(this.getBaseValue(), startOfTestWindow,</span>
<span class="fc" id="L135">        endOfTestWindow, this.getCombinedForecasts(), this.getBaseScale(),</span>
<span class="fc" id="L136">        this.getCapital());</span>
  }

  /**
   * Calculates the performance values for the given time frame, based on
   * the given baseValue, forecasts, baseScale and capital.
   * 
   * @param baseValue         {@link BaseValue} The base value upon which
   *                          the products' prices are to be based.
   * @param startOfTestWindow {@link LocalDateTime} First time interval for
   *                          testing.
   * @param endOfTestWindow   {@link LocalDateTime} Last time interval for
   *                          testing.
   * @param combinedForecasts {@code ValueDateTupel[]} Array of
   *                          {@link ValueDateTupel} containing the
   *                          forecasts for this performance calculation.
   * @param baseScale         {@code double} The scale the given forecasts
   *                          are based upon.
   * @param capital           {@code double} The starting capital.
   * @return {@code ValueDateTupel[]} An array of {@link ValueDateTupel}
   *         containing the value of all held assets + cash for each time
   *         interval between the given startOfTestWindow and
   *         endOfTestWindow.
   */
  public static ValueDateTupel[] calculatePerformanceValues(
      BaseValue baseValue, LocalDateTime startOfTestWindow,
      LocalDateTime endOfTestWindow, ValueDateTupel[] combinedForecasts,
      double baseScale, double capital) {

    try {
<span class="fc" id="L166">      Validator.validateTimeWindow(startOfTestWindow, endOfTestWindow,</span>
<span class="fc" id="L167">          baseValue.getValues());</span>
<span class="fc" id="L168">    } catch (IllegalArgumentException e) {</span>
      /*
       * If the message contains &quot;values&quot; the message references an error
       * in the given base values in combination with the given test
       * window.
       */
<span class="fc bfc" id="L174" title="All 2 branches covered.">      if (e.getMessage().contains(&quot;values&quot;))</span>
<span class="fc" id="L175">        throw new IllegalArgumentException(</span>
            &quot;Given base value and test window do not fit.&quot;, e);

<span class="fc" id="L178">      throw new IllegalArgumentException(MESSAGE_ILLEGAL_TEST_WINDOW, e);</span>
<span class="fc" id="L179">    }</span>

    try {
<span class="fc" id="L182">      Validator.validateTimeWindow(startOfTestWindow, endOfTestWindow,</span>
          combinedForecasts);
<span class="fc" id="L184">    } catch (IllegalArgumentException e) {</span>
      /*
       * The general checks of the test window would have thrown Exceptions
       * in the previous try-catch, so here we only have to deal with
       * combinedForecasts specific Exceptions.
       */
<span class="fc" id="L190">      throw new IllegalArgumentException(</span>
          &quot;Given forecasts and test window do not fit.&quot;, e);
<span class="fc" id="L192">    }</span>

    /* Fetch all base values inside the test window */
<span class="fc" id="L195">    ValueDateTupel[] relevantBaseValues = ValueDateTupel.getElements(</span>
<span class="fc" id="L196">        baseValue.getValues(), startOfTestWindow, endOfTestWindow);</span>

    /*
     * Get the product price factor to calculate long and short product
     * prices
     */
<span class="fc" id="L202">    double productPriceFactor = calculateProductPriceFactor(</span>
<span class="fc" id="L203">        ValueDateTupel.getValues(relevantBaseValues));</span>

    /*
     * Calculate the product prices based on the base value for each
     * interval inside the testing timespan and the calculated
     * productPriceFactor
     */
<span class="fc" id="L210">    ValueDateTupel[] productPrices = calculateProductPrices(</span>
        relevantBaseValues, productPriceFactor);

    /*
     * Calculate the short product prices based on the base value for each
     * interval inside the testing timespan and the calculated
     * productPriceFactor
     */
<span class="fc" id="L218">    ValueDateTupel[] relevantShortIndexValues = ValueDateTupel.getElements(</span>
<span class="fc" id="L219">        baseValue.getShortIndexValues(), startOfTestWindow,</span>
        endOfTestWindow);
<span class="fc" id="L221">    ValueDateTupel[] shortProductPrices = calculateProductPrices(</span>
        relevantShortIndexValues, productPriceFactor);

    /* Fetch all forecasts relevant for this backtest. */
<span class="fc" id="L225">    ValueDateTupel[] relevantCombinedForecasts = ValueDateTupel</span>
<span class="fc" id="L226">        .getElements(combinedForecasts, startOfTestWindow,</span>
            endOfTestWindow);

<span class="fc" id="L229">    ValueDateTupel[] performanceValues = {};</span>

<span class="fc" id="L231">    long longProductsCount = 0;</span>
<span class="fc" id="L232">    long shortProductsCount = 0;</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">    for (int i = 0; i &lt; relevantCombinedForecasts.length; i++) {</span>

      /*
       * Calculate the capital available for this time interval by
       * &quot;selling&quot; off all currently held positions at the this time
       * interval's prices.
       */
<span class="fc" id="L240">      capital += longProductsCount * productPrices[i].getValue();</span>
<span class="fc" id="L241">      capital += shortProductsCount * shortProductPrices[i].getValue();</span>

      /* Reset the products count as they were sold off */
<span class="fc" id="L244">      shortProductsCount = 0;</span>
<span class="fc" id="L245">      longProductsCount = 0;</span>

      /*
       * Add this capital as performance value, as the overall value of
       * cash + assets held will not change during buying.
       */
<span class="fc" id="L251">      ValueDateTupel performanceValue = new ValueDateTupel(</span>
<span class="fc" id="L252">          relevantCombinedForecasts[i].getDate(), capital);</span>
<span class="fc" id="L253">      performanceValues = ArrayUtils.add(performanceValues,</span>
          performanceValue);

<span class="fc bfc" id="L256" title="All 2 branches covered.">      if (relevantCombinedForecasts[i].getValue() &gt; 0) {</span>
        /* Long position */
<span class="fc" id="L258">        longProductsCount = calculateProductsCount(capital,</span>
<span class="fc" id="L259">            productPrices[i].getValue(),</span>
<span class="fc" id="L260">            relevantCombinedForecasts[i].getValue(), baseScale);</span>

        /*
         * &quot;Buy&quot; the calculated count of products and thus reduce the cash
         * capital
         */
<span class="fc" id="L266">        capital -= longProductsCount * productPrices[i].getValue();</span>

<span class="fc bfc" id="L268" title="All 2 branches covered.">      } else if (relevantCombinedForecasts[i].getValue() &lt; 0) {</span>
        /* short position */
<span class="fc" id="L270">        shortProductsCount = calculateProductsCount(capital,</span>
<span class="fc" id="L271">            shortProductPrices[i].getValue(),</span>
<span class="fc" id="L272">            relevantCombinedForecasts[i].getValue(), baseScale);</span>

        /*
         * &quot;Buy&quot; the calculated count of products and thus reduce the cash
         * capital
         */
<span class="fc" id="L278">        capital -= shortProductsCount * shortProductPrices[i].getValue();</span>
      } else {
        /*
         * If forecast was 0 nothing would be bought so no default-else
         * branch is needed.
         */
      }

    }
<span class="fc" id="L287">    return performanceValues;</span>
  }

  /**
   * Calls
   * {@link #calculatePerformanceValues(BaseValue, LocalDateTime, LocalDateTime, ValueDateTupel[], double, double)}
   * with instance properties.
   * 
   * @param startOfTestWindow {@link LocalDateTime} First time interval for
   *                          testing.
   * @param endOfTestWindow   {@link LocalDateTime} Last time interval for
   *                          testing.
   * @return {@code ValueDateTupel[]} by way of
   *         {@link #calculatePerformanceValues(BaseValue, LocalDateTime, LocalDateTime, ValueDateTupel[], double, double)}.
   */
  public ValueDateTupel[] calculatePerformanceValues(
      LocalDateTime startOfTestWindow, LocalDateTime endOfTestWindow) {
<span class="fc" id="L304">    return SubSystem.calculatePerformanceValues(this.getBaseValue(),</span>
<span class="fc" id="L305">        startOfTestWindow, endOfTestWindow, this.getCombinedForecasts(),</span>
<span class="fc" id="L306">        this.getBaseScale(), this.getCapital());</span>
  }

  /**
   * Calculates the combined forecasts for all rules of this Sub System.
   * 
   * @return {@code ValueDateTupel[]} The combined forecasts for all rules,
   *         multiplied by {@link DiversificationMultiplier#getValue()} of
   *         this Sub System.
   */
  private ValueDateTupel[] calculateCombinedForecasts() {
<span class="fc" id="L317">    Rule[] instanceRules = this.getRules();</span>
    /*
     * Calculate the weight by which all rules' forecasts shall be
     * multiplied by
     */
<span class="fc" id="L322">    double rulesWeight = 1d / instanceRules.length;</span>

<span class="fc" id="L324">    ValueDateTupel[] calculatedCombinedForecasts = {};</span>

    /* Step through the given rules */
<span class="fc bfc" id="L327" title="All 2 branches covered.">    for (int rulesIndex = 0; rulesIndex &lt; instanceRules.length; rulesIndex++) {</span>

      /* For each rule: Step through the forecasts */
<span class="fc" id="L330">      ValueDateTupel[] forecasts = instanceRules[rulesIndex]</span>
<span class="fc" id="L331">          .getForecasts();</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">      for (int fcIndex = 0; fcIndex &lt; forecasts.length; fcIndex++) {</span>

<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (rulesIndex == 0) {</span>
          /*
           * Combined forecasts must be filled with values on first
           * go-through
           */
<span class="fc" id="L339">          ValueDateTupel vdtToAdd = new ValueDateTupel(</span>
<span class="fc" id="L340">              forecasts[fcIndex].getDate(),</span>
<span class="fc" id="L341">              forecasts[fcIndex].getValue() * rulesWeight);</span>
<span class="fc" id="L342">          calculatedCombinedForecasts = ArrayUtils</span>
<span class="fc" id="L343">              .add(calculatedCombinedForecasts, vdtToAdd);</span>
<span class="fc" id="L344">        } else {</span>
          /*
           * If this is not the first go-through add the weighted forecasts
           * of the current rule
           */
<span class="fc" id="L349">          ValueDateTupel vdtToAdd = new ValueDateTupel(</span>
<span class="fc" id="L350">              calculatedCombinedForecasts[fcIndex].getDate(),</span>
<span class="fc" id="L351">              calculatedCombinedForecasts[fcIndex].getValue()</span>
<span class="fc" id="L352">                  + forecasts[fcIndex].getValue() * rulesWeight);</span>
<span class="fc" id="L353">          calculatedCombinedForecasts[fcIndex] = vdtToAdd;</span>
        }
      }
    }

    /*
     * Apply Diversification Multiplier to all forecast values. Cut off
     * Forecast values at 2 x base scale or -2 x base scale respectively
     */
<span class="fc" id="L362">    final double instanceBaseScale = this.getBaseScale();</span>
<span class="fc" id="L363">    final double diversificationMultiplierValue = this</span>
<span class="fc" id="L364">        .getDiversificationMultiplier().getValue();</span>
<span class="fc" id="L365">    final double MAX_VALUE = instanceBaseScale * 2;</span>
<span class="fc" id="L366">    final double MIN_VALUE = 0 - MAX_VALUE;</span>

<span class="fc bfc" id="L368" title="All 2 branches covered.">    for (int fcIndex = 0; fcIndex &lt; calculatedCombinedForecasts.length; fcIndex++) {</span>
<span class="fc" id="L369">      double fcWithDM = calculatedCombinedForecasts[fcIndex].getValue()</span>
          * diversificationMultiplierValue;
<span class="fc bfc" id="L371" title="All 2 branches covered.">      if (fcWithDM &gt; MAX_VALUE)</span>
<span class="fc" id="L372">        fcWithDM = MAX_VALUE;</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">      if (fcWithDM &lt; MIN_VALUE)</span>
<span class="fc" id="L374">        fcWithDM = MIN_VALUE;</span>

<span class="fc" id="L376">      calculatedCombinedForecasts[fcIndex].setValue(fcWithDM);</span>
    }

<span class="fc" id="L379">    return calculatedCombinedForecasts;</span>
  }

  /**
   * Call {@link SubSystem#calculateProductPriceFactor(double[], double)}
   * passing PRICE_FACTOR_BASE_SCALE as param.
   * 
   * @see SubSystem#calculateProductPriceFactor(double[], double)
   * @param values {@code double[]} An Array of values the factor is to be
   *               calculated for
   * @return {@code double} The calculated factor.
   */
  private static double calculateProductPriceFactor(double[] values) {
<span class="fc" id="L392">    return SubSystem.calculateProductPriceFactor(values,</span>
        PRICE_FACTOR_BASE_SCALE);
  }

  /**
   * Calculate the factor by which all of the given values must be
   * multiplied so their products have an average of priceFactorBaseScale.
   * &lt;br&gt;
   * The factor is calculated by inverting the average of the given values
   * divided by the given priceFactorBaseScale.
   * 
   * @param values               {@code double[]} An Array of values the
   *                             factor is to be calculated for
   * @param priceFactorBaseScale {@code double} The base scale to use.
   * @return {@code double} The calculated factor.
   */
  private static double calculateProductPriceFactor(double[] values,
      double priceFactorBaseScale) {
<span class="fc" id="L410">    double averageCourseValue = Util.calculateAverage(values);</span>

<span class="fc" id="L412">    return 1 / (averageCourseValue / priceFactorBaseScale);</span>
  }

  /**
   * Calculate product prices based on the given array of values and a
   * given product price factor.
   * 
   * @param baseValues         {@code ValueDateTupel[]} The values the
   *                           prices are to be based on.
   * @param productPriceFactor {@code double} The factor used to calculate
   *                           the product prices.
   * @return {@code ValueDateTupel[]} An array of prices using the dates of
   *         the given baseValues.
   */
  private static ValueDateTupel[] calculateProductPrices(
      ValueDateTupel[] baseValues, double productPriceFactor) {
<span class="fc" id="L428">    ValueDateTupel[] productPrices = {};</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">    for (ValueDateTupel baseValue : baseValues)</span>
<span class="fc" id="L430">      productPrices = ValueDateTupel.addOneAt(productPrices,</span>
<span class="fc" id="L431">          new ValueDateTupel(baseValue.getDate(),</span>
<span class="fc" id="L432">              baseValue.getValue() * productPriceFactor),</span>
          productPrices.length);

<span class="fc" id="L435">    return productPrices;</span>
  }

  /**
   * Calculates the products to buy during a trading period according to
   * the given price and given forecast.
   * 
   * @param capital   {@code double} The capital available for trading.
   * @param price     {@code double} The price at which a product can be
   *                  bought.
   * @param forecast  {@code double} The forecast for the current trading
   *                  period.
   * @param baseScale {@code double} The base scale by which the given
   *                  forecast is scaled.
   * @return {@code int} The number of products to buy.
   */
  private static long calculateProductsCount(double capital, double price,
      double forecast, double baseScale) {
    /* Number of products if forecast had MAX_VALUE */
<span class="fc" id="L454">    double maxProductsCount = capital / price;</span>

    /* Number of products if forecast was 1 */
<span class="fc" id="L457">    double fcOneProductsCounts = maxProductsCount / (baseScale * 2);</span>

    /*
     * Invert current forecast if it's negative to always generate a
     * positive number of products
     */
<span class="fc bfc" id="L463" title="All 2 branches covered.">    if (forecast &lt; 0)</span>
<span class="fc" id="L464">      forecast *= -1;</span>

    /*
     * Number of products for actual forecast. Accept rounding
     * inaccuracies.
     */
<span class="fc" id="L470">    return (long) (fcOneProductsCounts * forecast);</span>
  }

  /**
   * Validate the given input parameters.
   * 
   * @param baseValue {@link BaseValue} The baseValue to validate. Must
   *                  pass {@link Validator#validateBaseValue(BaseValue)}.
   * @param rules     {@code Rule[]} The rules to validate.
   *                  &lt;ul&gt;
   *                  &lt;li&gt;Must pass
   *                  {@link Validator#validateRules(Rule[])}&lt;/li&gt;
   *                  &lt;li&gt;Each rule's base value must be same as the given
   *                  base value.&lt;/li&gt;
   *                  &lt;/ul&gt;
   * @param capital   {@code double} The capital to validate. Must pass
   *                  {@link Validator#validatePositiveDouble(double)}.
   * @param baseScale {@code double} The base scale to validate. Must pass
   *                  {@link Validator#validatePositiveDouble(double)}.
   * @throws IllegalArgumentException if any of the above criteria is not
   *                                  met.
   */
  private static void validateInput(BaseValue baseValue, Rule[] rules,
      double capital, double baseScale) {
<span class="fc" id="L494">    Validator.validateBaseValue(baseValue);</span>

<span class="fc" id="L496">    Validator.validateRules(rules);</span>

<span class="fc" id="L498">    Validator.validateRulesVsBaseValue(rules, baseValue);</span>

    try {
<span class="fc" id="L501">      Validator.validatePositiveDouble(capital);</span>
<span class="fc" id="L502">    } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L503">      throw new IllegalArgumentException(</span>
          &quot;Given capital does not meet specifications.&quot;, e);
<span class="fc" id="L505">    }</span>

    try {
<span class="fc" id="L508">      Validator.validatePositiveDouble(baseScale);</span>
<span class="fc" id="L509">    } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L510">      throw new IllegalArgumentException(</span>
          &quot;Given base scale does not meet specifications.&quot;, e);
<span class="fc" id="L512">    }</span>

<span class="fc" id="L514">    Validator.validateRulesVsBaseScale(rules, baseScale);</span>
<span class="fc" id="L515">  }</span>

  /**
   * Validate the given rules. &lt;br&gt;
   * Rules have to fulfill the following criteria:
   * &lt;ul&gt;
   * &lt;li&gt;Be unique by {@link Util#areRulesUnique(Rule[])}&lt;/li&gt;
   * &lt;li&gt;Equal in startOfReferenceWindow and endOfReferenceWinow by
   * {@link LocalDateTime#isEqual(ChronoLocalDateTime)}&lt;/li&gt;
   * &lt;/ul&gt;
   * 
   * @param rules {@code Rule[]} Rules that are to be checked.
   * @throws IllegalArgumentException if the given rules are not unique.
   */
  private static void validateRules(Rule[] rules) {
<span class="fc bfc" id="L530" title="All 2 branches covered.">    if (!Util.areRulesUnique(rules))</span>
<span class="fc" id="L531">      throw new IllegalArgumentException(&quot;The given rules are not unique.&quot;</span>
          + &quot; Only unique rules can be used.&quot;);

    /* All rules need to have the same reference window */
<span class="fc bfc" id="L535" title="All 2 branches covered.">    for (int i = 1; i &lt; rules.length; i++) {</span>
<span class="fc" id="L536">      if (!rules[i].getStartOfReferenceWindow()</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">          .isEqual(rules[i - 1].getStartOfReferenceWindow())</span>
<span class="fc" id="L538">          || !rules[i].getEndOfReferenceWindow()</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">              .isEqual(rules[i - 1].getEndOfReferenceWindow())) {</span>
<span class="fc" id="L540">        throw new IllegalArgumentException(</span>
            &quot;All rules need to have the same reference window but rules at&quot;
                + &quot; position &quot; + (i - 1) + &quot; and &quot; + i + &quot; differ.&quot;);
      }
    }

<span class="fc" id="L546">  }</span>

  /**
   * ======================================================================
   * OVERRIDES
   * ======================================================================
   */

  /**
   * A hash code for this SubSystem.
   */
  @GeneratedCode
  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = Double.doubleToLongBits(baseScale);
    result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
    result = prime * result
        + ((baseValue == null) ? 0 : baseValue.hashCode());
    temp = Double.doubleToLongBits(capital);
    result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
    result = prime * result + Arrays.hashCode(combinedForecasts);
    result = prime * result + ((diversificationMultiplier == null) ? 0
        : diversificationMultiplier.hashCode());
    result = prime * result + Arrays.hashCode(rules);
    return result;
  }

  /**
   * Checks if this SubSystem is equal to another SubSystem.
   */
  @GeneratedCode
  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    SubSystem other = (SubSystem) obj;
    if (Double.doubleToLongBits(baseScale) != Double
        .doubleToLongBits(other.baseScale))
      return false;
    if (baseValue == null) {
      if (other.baseValue != null)
        return false;
    } else if (!baseValue.equals(other.baseValue))
      return false;
    if (Double.doubleToLongBits(capital) != Double
        .doubleToLongBits(other.capital))
      return false;
    if (!Arrays.equals(combinedForecasts, other.combinedForecasts))
      return false;
    if (diversificationMultiplier == null) {
      if (other.diversificationMultiplier != null)
        return false;
    } else if (!diversificationMultiplier
        .equals(other.diversificationMultiplier))
      return false;
    if (!Arrays.equals(rules, other.rules))
      return false;
    return true;
  }

  /**
   * Outputs the fields of this SubSystem as a {@code String}.
   */
  @GeneratedCode
  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(&quot;SubSystem [baseValue=&quot;);
    builder.append(baseValue);
    builder.append(&quot;, rules=&quot;);
    builder.append(Arrays.toString(rules));
    builder.append(&quot;, diversificationMultiplier=&quot;);
    builder.append(diversificationMultiplier);
    builder.append(&quot;, capital=&quot;);
    builder.append(capital);
    builder.append(&quot;, combinedForecasts=&quot;);
    builder.append(Arrays.toString(combinedForecasts));
    builder.append(&quot;, baseScale=&quot;);
    builder.append(baseScale);
    builder.append(&quot;]&quot;);
    return builder.toString();
  }

  /**
   * ======================================================================
   * GETTERS AND SETTERS
   * ======================================================================
   */

  /**
   * Get the {@link BaseValue} for this subsystem.
   * 
   * @return baseValue SubSystem
   */
  public BaseValue getBaseValue() {
<span class="fc" id="L648">    return baseValue;</span>
  }

  /**
   * Set the {@link BaseValue} for this subsystem.
   * 
   * @param baseValue the baseValue to set
   */
  private void setBaseValue(BaseValue baseValue) {
<span class="fc" id="L657">    this.baseValue = baseValue;</span>
<span class="fc" id="L658">  }</span>

  /**
   * Get the rules for this subsystem.
   * 
   * @return rules SubSystem
   */
  public Rule[] getRules() {
<span class="fc" id="L666">    return rules;</span>
  }

  /**
   * Set the rules for this subsystem.
   * 
   * @param rules the rules to set
   */
  public void setRules(Rule[] rules) {
<span class="fc" id="L675">    this.rules = rules;</span>
<span class="fc" id="L676">  }</span>

  /**
   * Get the {@link DiversificationMultiplier} for this subsystem.
   * 
   * @return diversificationMultiplier SubSystem
   */
  public DiversificationMultiplier getDiversificationMultiplier() {
<span class="fc" id="L684">    return diversificationMultiplier;</span>
  }

  /**
   * Set the {@link DiversificationMultiplier} for this subsystem.
   * 
   * @param diversificationMultiplier the diversificationMultiplier to set
   */
  private void setDiversificationMultiplier(
      DiversificationMultiplier diversificationMultiplier) {
<span class="fc" id="L694">    this.diversificationMultiplier = diversificationMultiplier;</span>
<span class="fc" id="L695">  }</span>

  /**
   * Get the capital for this subsystem.
   * 
   * @return capital SubSystem
   */
  public double getCapital() {
<span class="fc" id="L703">    return capital;</span>
  }

  /**
   * Set the capital for this subsystem.
   * 
   * @param capital the capital to set
   */
  private void setCapital(double capital) {
<span class="fc" id="L712">    this.capital = capital;</span>
<span class="fc" id="L713">  }</span>

  /**
   * Get the combined forecasts for this subsystem.
   * 
   * @return combinedForecasts SubSystem
   */
  public ValueDateTupel[] getCombinedForecasts() {
<span class="fc" id="L721">    return combinedForecasts;</span>
  }

  /**
   * Set the combined forecasts for this subsystem.
   * 
   * @param combinedForecasts the combinedForecasts to set
   */
  public void setCombinedForecasts(ValueDateTupel[] combinedForecasts) {
<span class="fc" id="L730">    this.combinedForecasts = combinedForecasts;</span>
<span class="fc" id="L731">  }</span>

  /**
   * Get the base scale for this subsystem.
   * 
   * @return baseScale SubSystem
   */
  public double getBaseScale() {
<span class="fc" id="L739">    return baseScale;</span>
  }

  /**
   * Set the base scale for this subsystem.
   * 
   * @param baseScale the baseScale to set
   */
  public void setBaseScale(double baseScale) {
<span class="fc" id="L748">    this.baseScale = baseScale;</span>
<span class="fc" id="L749">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
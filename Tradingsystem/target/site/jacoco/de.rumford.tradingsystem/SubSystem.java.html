<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SubSystem.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tradingsystem</a> &gt; <a href="index.source.html" class="el_package">de.rumford.tradingsystem</a> &gt; <span class="el_source">SubSystem.java</span></div><h1>SubSystem.java</h1><pre class="source lang-java linenums">package de.rumford.tradingsystem;

import java.time.LocalDateTime;
import java.time.chrono.ChronoLocalDateTime;
import java.util.Arrays;

import org.apache.commons.lang3.ArrayUtils;

import de.rumford.tradingsystem.helper.GeneratedCode;
import de.rumford.tradingsystem.helper.Util;
import de.rumford.tradingsystem.helper.Validator;
import de.rumford.tradingsystem.helper.ValueDateTupel;

/**
 * The SubSystem is the most parental Structure in this library and contains (directly or indirectly) all other
 * (non-static) classes. It combines rules and base values and is thus the only point to calculate positions and perform
 * backtesting of performance. By containing a {@link DiversificationMultiplier} it copes with the diversity between its
 * rules and thus meets volatility target and scale.
 * 
 * @author Max Rumford
 */
public class SubSystem {

	/*
	 * The value to which the product prices shall be scaled to. Effect rises if higher and capital goes lower.
	 */
	private static final double PRICE_FACTOR_BASE_SCALE = 1;

	/* An Exception message. */
	private static final String MESSAGE_ILLEGAL_TEST_WINDOW = &quot;The given test window does not meet specifications.&quot;;

	/* The base value to use for performance calculation. */
	private BaseValue baseValue;
	/* The rules to be governed in this subsystem. */
	private Rule[] rules;
	/* The diversification multiplier for this subsystem. */
	private DiversificationMultiplier diversificationMultiplier;
	/* The starting capital used for performance calculation. */
	private double capital;
	/* The combined forecasts of all rules. */
	private ValueDateTupel[] combinedForecasts;
	/* The value all forecasts shall be scaled to. */
	private double baseScale;

	/**
	 * Constructor for the SubSystem class.
	 * 
	 * @param baseValue {@link BaseValue} The base value to be used for all the given rules' calculations. See
	 *                  {@link #validateInput( BaseValue, Rule[], double, double)} for limitations.
	 * @param rules     {@code Rule[]} Array of {@link Rule} to be used for forecast calculations in this SubSystem. See
	 *                  {@link #validateInput( BaseValue, Rule[], double, double)} for limitations.
	 * @param capital   {@code double} The capital to be managed by this SubSystem. See
	 *                  {@link #validateInput( BaseValue, Rule[], double, double)} for limitations.
	 * @param baseScale {@code double} The base scale for this SubSystem's forecasts. See
	 *                  {@link #validateInput( BaseValue, Rule[], double, double)} for limitations.
	 */
<span class="fc" id="L57">	public SubSystem(BaseValue baseValue, Rule[] rules, double capital, double baseScale) {</span>

<span class="fc" id="L59">		validateInput(baseValue, rules, capital, baseScale);</span>

<span class="fc" id="L61">		validateRules(rules);</span>
<span class="fc" id="L62">		this.setRules(rules);</span>

<span class="fc" id="L64">		this.setBaseValue(baseValue);</span>
<span class="fc" id="L65">		this.setCapital(capital);</span>
<span class="fc" id="L66">		this.setBaseScale(baseScale);</span>
<span class="fc" id="L67">		this.setDiversificationMultiplier(new DiversificationMultiplier(rules));</span>
<span class="fc" id="L68">		this.setCombinedForecasts(this.calculateCombinedForecasts());</span>
<span class="fc" id="L69">	}</span>

	/**
	 * Performs a backtest for the given parameters. Utilizes
	 * {@link #calculatePerformanceValues(BaseValue, LocalDateTime, LocalDateTime, ValueDateTupel[], double, double)}
	 * for actual performance calculation and returns performance value for the last day.
	 * 
	 * @see                      SubSystem#calculatePerformanceValues(BaseValue, LocalDateTime, LocalDateTime,
	 *                           ValueDateTupel[], double, double)
	 * @param  baseValue         {@link BaseValue} The base value to be tested against.
	 * @param  startOfTestWindow {@link LocalDateTime} First time interval of test window.
	 * @param  endOfTestWindow   {@link LocalDateTime} Last time interval of test window.
	 * @param  combinedForecasts {@code ValueDateTupel[]} The forecasts to be used for performance calculation.
	 * @param  baseScale         {@code double} The value to which to scale the forecasts to.
	 * @param  capital           {@code double} The starting capital.
	 * @return                   {@code double} The performance value on the last day of the given test window.
	 */
	public static double backtest(BaseValue baseValue, LocalDateTime startOfTestWindow, LocalDateTime endOfTestWindow,
	        ValueDateTupel[] combinedForecasts, double baseScale, double capital) {

<span class="fc" id="L89">		ValueDateTupel[] performanceValues = calculatePerformanceValues(baseValue, startOfTestWindow, endOfTestWindow,</span>
		        combinedForecasts, baseScale, capital);

<span class="fc" id="L92">		return performanceValues[performanceValues.length - 1].getValue();</span>
	}

	/**
	 * Calls
	 * {@link #calculatePerformanceValues(BaseValue, LocalDateTime, LocalDateTime, ValueDateTupel[], double, double)}
	 * with instance properties.
	 * 
	 * @param  startOfTestWindow {@link LocalDateTime} First time interval of test window.
	 * @param  endOfTestWindow   {@link LocalDateTime} Last time interval of test window.
	 * @return                   {@code double} by way of
	 *                           {@link #backtest(BaseValue, LocalDateTime, LocalDateTime, ValueDateTupel[], double, double)}.
	 */
	public double backtest(LocalDateTime startOfTestWindow, LocalDateTime endOfTestWindow) {
<span class="fc" id="L106">		return SubSystem.backtest(this.getBaseValue(), startOfTestWindow, endOfTestWindow, this.getCombinedForecasts(),</span>
<span class="fc" id="L107">		        this.getBaseScale(), this.getCapital());</span>
	}

	/**
	 * Calculates the performance values for the given time frame, based on the given baseValue, forecasts, baseScale
	 * and capital.
	 * 
	 * @param  baseValue         {@link BaseValue} The base value upon which the products' prices are to be based.
	 * @param  startOfTestWindow {@link LocalDateTime} First time interval for testing.
	 * @param  endOfTestWindow   {@link LocalDateTime} Last time interval for testing.
	 * @param  combinedForecasts {@code ValueDateTupel[]} Array of {@link ValueDateTupel} containing the forecasts for
	 *                           this performance calculation.
	 * @param  baseScale         {@code double} The scale the given forecasts are based upon.
	 * @param  capital           {@code double} The starting capital.
	 * @return                   {@code ValueDateTupel[]} An array of {@link ValueDateTupel} containing the value of all
	 *                           held assets + cash for each time interval between the given startOfTestWindow and
	 *                           endOfTestWindow.
	 */
	public static ValueDateTupel[] calculatePerformanceValues(BaseValue baseValue, LocalDateTime startOfTestWindow,
	        LocalDateTime endOfTestWindow, ValueDateTupel[] combinedForecasts, double baseScale, double capital) {

		try {
<span class="fc" id="L129">			Validator.validateTimeWindow(startOfTestWindow, endOfTestWindow, baseValue.getValues());</span>
<span class="fc" id="L130">		} catch (IllegalArgumentException e) {</span>
			/*
			 * If the message contains &quot;values&quot; the message references an error in the given base values in combination
			 * with the given test window.
			 */
<span class="fc bfc" id="L135" title="All 2 branches covered.">			if (e.getMessage().contains(&quot;values&quot;))</span>
<span class="fc" id="L136">				throw new IllegalArgumentException(&quot;Given base value and test window do not fit.&quot;, e);</span>

<span class="fc" id="L138">			throw new IllegalArgumentException(MESSAGE_ILLEGAL_TEST_WINDOW, e);</span>
<span class="fc" id="L139">		}</span>

		try {
<span class="fc" id="L142">			Validator.validateTimeWindow(startOfTestWindow, endOfTestWindow, combinedForecasts);</span>
<span class="fc" id="L143">		} catch (IllegalArgumentException e) {</span>
			/*
			 * The general checks of the test window would have thrown Exceptions in the previous try-catch, so here we
			 * only have to deal with combinedForecasts specific Exceptions.
			 */
<span class="fc" id="L148">			throw new IllegalArgumentException(&quot;Given forecasts and test window do not fit.&quot;, e);</span>
<span class="fc" id="L149">		}</span>

		/* Fetch all base values inside the test window */
<span class="fc" id="L152">		ValueDateTupel[] relevantBaseValues = ValueDateTupel.getElements(baseValue.getValues(), startOfTestWindow,</span>
		        endOfTestWindow);

		/*
		 * Get the product price factor to calculate long and short product prices
		 */
<span class="fc" id="L158">		double productPriceFactor = calculateProductPriceFactor(ValueDateTupel.getValues(relevantBaseValues));</span>

		/*
		 * Calculate the product prices based on the base value for each interval inside the testing timespan and the
		 * calculated productPriceFactor
		 */
<span class="fc" id="L164">		ValueDateTupel[] productPrices = calculateProductPrices(relevantBaseValues, productPriceFactor);</span>

		/*
		 * Calculate the short product prices based on the base value for each interval inside the testing timespan and
		 * the calculated productPriceFactor
		 */
<span class="fc" id="L170">		ValueDateTupel[] relevantShortIndexValues = ValueDateTupel.getElements(baseValue.getShortIndexValues(),</span>
		        startOfTestWindow, endOfTestWindow);
<span class="fc" id="L172">		ValueDateTupel[] shortProductPrices = calculateProductPrices(relevantShortIndexValues, productPriceFactor);</span>

		/* Fetch all forecasts relevant for this backtest. */
<span class="fc" id="L175">		ValueDateTupel[] relevantCombinedForecasts = ValueDateTupel.getElements(combinedForecasts, startOfTestWindow,</span>
		        endOfTestWindow);

<span class="fc" id="L178">		ValueDateTupel[] performanceValues = {};</span>

<span class="fc" id="L180">		long longProductsCount = 0;</span>
<span class="fc" id="L181">		long shortProductsCount = 0;</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">		for (int i = 0; i &lt; relevantCombinedForecasts.length; i++) {</span>

			/*
			 * Calculate the capital available for this time interval by &quot;selling&quot; off all currently held positions at
			 * the this time interval's prices.
			 */
<span class="fc" id="L188">			capital += longProductsCount * productPrices[i].getValue();</span>
<span class="fc" id="L189">			capital += shortProductsCount * shortProductPrices[i].getValue();</span>

			/* Reset the products count as they were sold off */
<span class="fc" id="L192">			shortProductsCount = 0;</span>
<span class="fc" id="L193">			longProductsCount = 0;</span>

			/*
			 * Add this capital as performance value, as the overall value of cash + assets held will not change during
			 * buying.
			 */
<span class="fc" id="L199">			ValueDateTupel performanceValue = new ValueDateTupel(relevantCombinedForecasts[i].getDate(), capital);</span>
<span class="fc" id="L200">			performanceValues = ArrayUtils.add(performanceValues, performanceValue);</span>

<span class="fc bfc" id="L202" title="All 2 branches covered.">			if (relevantCombinedForecasts[i].getValue() &gt; 0) {</span>
				/* Long position */
<span class="fc" id="L204">				longProductsCount = calculateProductsCount(capital, productPrices[i].getValue(),</span>
<span class="fc" id="L205">				        relevantCombinedForecasts[i].getValue(), baseScale);</span>

				/*
				 * &quot;Buy&quot; the calculated count of products and thus reduce the cash capital
				 */
<span class="fc" id="L210">				capital -= longProductsCount * productPrices[i].getValue();</span>

<span class="fc bfc" id="L212" title="All 2 branches covered.">			} else if (relevantCombinedForecasts[i].getValue() &lt; 0) {</span>
				/* short position */
<span class="fc" id="L214">				shortProductsCount = calculateProductsCount(capital, shortProductPrices[i].getValue(),</span>
<span class="fc" id="L215">				        relevantCombinedForecasts[i].getValue(), baseScale);</span>

				/*
				 * &quot;Buy&quot; the calculated count of products and thus reduce the cash capital
				 */
<span class="fc" id="L220">				capital -= shortProductsCount * shortProductPrices[i].getValue();</span>
			} else {
				/*
				 * If forecast was 0 nothing would be bought so no default-else branch is needed.
				 */
			}

		}
<span class="fc" id="L228">		return performanceValues;</span>
	}

	/**
	 * Calls
	 * {@link #calculatePerformanceValues(BaseValue, LocalDateTime, LocalDateTime, ValueDateTupel[], double, double)}
	 * with instance properties.
	 * 
	 * @param  startOfTestWindow {@link LocalDateTime} First time interval for testing.
	 * @param  endOfTestWindow   {@link LocalDateTime} Last time interval for testing.
	 * @return                   {@code ValueDateTupel[]} by way of
	 *                           {@link #calculatePerformanceValues(BaseValue, LocalDateTime, LocalDateTime, ValueDateTupel[], double, double)}.
	 */
	public ValueDateTupel[] calculatePerformanceValues(LocalDateTime startOfTestWindow, LocalDateTime endOfTestWindow) {
<span class="fc" id="L242">		return SubSystem.calculatePerformanceValues(this.getBaseValue(), startOfTestWindow, endOfTestWindow,</span>
<span class="fc" id="L243">		        this.getCombinedForecasts(), this.getBaseScale(), this.getCapital());</span>
	}

	/**
	 * Calculates the combined forecasts for all rules of this Sub System.
	 * 
	 * @return {@code ValueDateTupel[]} The combined forecasts for all rules, multiplied by
	 *         {@link DiversificationMultiplier#getValue()} of this Sub System.
	 */
	private ValueDateTupel[] calculateCombinedForecasts() {
<span class="fc" id="L253">		Rule[] instanceRules = this.getRules();</span>
		/*
		 * Calculate the weight by which all rules' forecasts shall be multiplied by
		 */
<span class="fc" id="L257">		double rulesWeight = 1d / instanceRules.length;</span>

<span class="fc" id="L259">		ValueDateTupel[] calculatedCombinedForecasts = {};</span>

		/* Step through the given rules */
<span class="fc bfc" id="L262" title="All 2 branches covered.">		for (int rulesIndex = 0; rulesIndex &lt; instanceRules.length; rulesIndex++) {</span>

			/* For each rule: Step through the forecasts */
<span class="fc" id="L265">			ValueDateTupel[] forecasts = instanceRules[rulesIndex].getForecasts();</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">			for (int fcIndex = 0; fcIndex &lt; forecasts.length; fcIndex++) {</span>

<span class="fc bfc" id="L268" title="All 2 branches covered.">				if (rulesIndex == 0) {</span>
					/*
					 * Combined forecasts must be filled with values on first go-through
					 */
<span class="fc" id="L272">					ValueDateTupel vdtToAdd = new ValueDateTupel(forecasts[fcIndex].getDate(),</span>
<span class="fc" id="L273">					        forecasts[fcIndex].getValue() * rulesWeight);</span>
<span class="fc" id="L274">					calculatedCombinedForecasts = ArrayUtils.add(calculatedCombinedForecasts, vdtToAdd);</span>
<span class="fc" id="L275">				} else {</span>
					/*
					 * If this is not the first go-through add the weighted forecasts of the current rule
					 */
<span class="fc" id="L279">					ValueDateTupel vdtToAdd = new ValueDateTupel(calculatedCombinedForecasts[fcIndex].getDate(),</span>
<span class="fc" id="L280">					        calculatedCombinedForecasts[fcIndex].getValue()</span>
<span class="fc" id="L281">					                + forecasts[fcIndex].getValue() * rulesWeight);</span>
<span class="fc" id="L282">					calculatedCombinedForecasts[fcIndex] = vdtToAdd;</span>
				}
			}
		}

		/*
		 * Apply Diversification Multiplier to all forecast values. Cut off Forecast values at 2 x base scale or -2 x
		 * base scale respectively
		 */
<span class="fc" id="L291">		final double instanceBaseScale = this.getBaseScale();</span>
<span class="fc" id="L292">		final double diversificationMultiplierValue = this.getDiversificationMultiplier().getValue();</span>
<span class="fc" id="L293">		final double MAX_VALUE = instanceBaseScale * 2;</span>
<span class="fc" id="L294">		final double MIN_VALUE = 0 - MAX_VALUE;</span>

<span class="fc bfc" id="L296" title="All 2 branches covered.">		for (int fcIndex = 0; fcIndex &lt; calculatedCombinedForecasts.length; fcIndex++) {</span>
<span class="fc" id="L297">			double fcWithDM = calculatedCombinedForecasts[fcIndex].getValue() * diversificationMultiplierValue;</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">			if (fcWithDM &gt; MAX_VALUE)</span>
<span class="fc" id="L299">				fcWithDM = MAX_VALUE;</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">			if (fcWithDM &lt; MIN_VALUE)</span>
<span class="fc" id="L301">				fcWithDM = MIN_VALUE;</span>

<span class="fc" id="L303">			calculatedCombinedForecasts[fcIndex].setValue(fcWithDM);</span>
		}

<span class="fc" id="L306">		return calculatedCombinedForecasts;</span>
	}

	/**
	 * Call {@link SubSystem#calculateProductPriceFactor(double[], double)} passing PRICE_FACTOR_BASE_SCALE as param.
	 * 
	 * @see           SubSystem#calculateProductPriceFactor(double[], double)
	 * @param  values {@code double[]} An Array of values the factor is to be calculated for
	 * @return        {@code double} The calculated factor.
	 */
	private static double calculateProductPriceFactor(double[] values) {
<span class="fc" id="L317">		return SubSystem.calculateProductPriceFactor(values, PRICE_FACTOR_BASE_SCALE);</span>
	}

	/**
	 * Calculate the factor by which all of the given values must be multiplied so their products have an average of
	 * priceFactorBaseScale. &lt;br&gt;
	 * The factor is calculated by inverting the average of the given values divided by the given priceFactorBaseScale.
	 * 
	 * @param  values               {@code double[]} An Array of values the factor is to be calculated for
	 * @param  priceFactorBaseScale {@code double} The base scale to use.
	 * @return                      {@code double} The calculated factor.
	 */
	private static double calculateProductPriceFactor(double[] values, double priceFactorBaseScale) {
<span class="fc" id="L330">		double averageCourseValue = Util.calculateAverage(values);</span>

<span class="fc" id="L332">		return 1 / (averageCourseValue / priceFactorBaseScale);</span>
	}

	/**
	 * Calculate product prices based on the given array of values and a given product price factor.
	 * 
	 * @param  baseValues         {@code ValueDateTupel[]} The values the prices are to be based on.
	 * @param  productPriceFactor {@code double} The factor used to calculate the product prices.
	 * @return                    {@code ValueDateTupel[]} An array of prices using the dates of the given baseValues.
	 */
	private static ValueDateTupel[] calculateProductPrices(ValueDateTupel[] baseValues, double productPriceFactor) {
<span class="fc" id="L343">		ValueDateTupel[] productPrices = {};</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">		for (ValueDateTupel baseValue : baseValues)</span>
<span class="fc" id="L345">			productPrices = ValueDateTupel.addOneAt(productPrices,</span>
<span class="fc" id="L346">			        new ValueDateTupel(baseValue.getDate(), baseValue.getValue() * productPriceFactor),</span>
			        productPrices.length);

<span class="fc" id="L349">		return productPrices;</span>
	}

	/**
	 * Calculates the products to buy during a trading period according to the given price and given forecast.
	 * 
	 * @param  capital   {@code double} The capital available for trading.
	 * @param  price     {@code double} The price at which a product can be bought.
	 * @param  forecast  {@code double} The forecast for the current trading period.
	 * @param  baseScale {@code double} The base scale by which the given forecast is scaled.
	 * @return           {@code int} The number of products to buy.
	 */
	private static long calculateProductsCount(double capital, double price, double forecast, double baseScale) {
		/* Number of products if forecast had MAX_VALUE */
<span class="fc" id="L363">		double maxProductsCount = capital / price;</span>

		/* Number of products if forecast was 1 */
<span class="fc" id="L366">		double fcOneProductsCounts = maxProductsCount / (baseScale * 2);</span>

		/*
		 * Invert current forecast if it's negative to always generate a positive number of products
		 */
<span class="fc bfc" id="L371" title="All 2 branches covered.">		if (forecast &lt; 0)</span>
<span class="fc" id="L372">			forecast *= -1;</span>

		/*
		 * Number of products for actual forecast. Accept rounding inaccuracies.
		 */
<span class="fc" id="L377">		return (long) (fcOneProductsCounts * forecast);</span>
	}

	/**
	 * Validate the given input parameters.
	 * 
	 * @param  baseValue                {@link BaseValue} The baseValue to validate. Must pass
	 *                                  {@link Validator#validateBaseValue(BaseValue)}.
	 * @param  rules                    {@code Rule[]} The rules to validate.
	 *                                  &lt;ul&gt;
	 *                                  &lt;li&gt;Must pass {@link Validator#validateRules(Rule[])}&lt;/li&gt;
	 *                                  &lt;li&gt;Each rule's base value must be same as the given base value.&lt;/li&gt;
	 *                                  &lt;/ul&gt;
	 * @param  capital                  {@code double} The capital to validate. Must pass
	 *                                  {@link Validator#validatePositiveDouble(double)}.
	 * @param  baseScale                {@code double} The base scale to validate. Must pass
	 *                                  {@link Validator#validatePositiveDouble(double)}.
	 * @throws IllegalArgumentException if any of the above criteria is not met.
	 */
	private static void validateInput(BaseValue baseValue, Rule[] rules, double capital, double baseScale) {
<span class="fc" id="L397">		Validator.validateBaseValue(baseValue);</span>

<span class="fc" id="L399">		Validator.validateRules(rules);</span>

<span class="fc" id="L401">		Validator.validateRulesVsBaseValue(rules, baseValue);</span>

		try {
<span class="fc" id="L404">			Validator.validatePositiveDouble(capital);</span>
<span class="fc" id="L405">		} catch (IllegalArgumentException e) {</span>
<span class="fc" id="L406">			throw new IllegalArgumentException(&quot;Given capital does not meet specifications.&quot;, e);</span>
<span class="fc" id="L407">		}</span>

		try {
<span class="fc" id="L410">			Validator.validatePositiveDouble(baseScale);</span>
<span class="fc" id="L411">		} catch (IllegalArgumentException e) {</span>
<span class="fc" id="L412">			throw new IllegalArgumentException(&quot;Given base scale does not meet specifications.&quot;, e);</span>
<span class="fc" id="L413">		}</span>

<span class="fc" id="L415">		Validator.validateRulesVsBaseScale(rules, baseScale);</span>
<span class="fc" id="L416">	}</span>

	/**
	 * Validate the given rules. &lt;br&gt;
	 * Rules have to fulfill the following criteria:
	 * &lt;ul&gt;
	 * &lt;li&gt;Be unique by {@link Util#areRulesUnique(Rule[])}&lt;/li&gt;
	 * &lt;li&gt;Equal in startOfReferenceWindow and endOfReferenceWinow by
	 * {@link LocalDateTime#isEqual(ChronoLocalDateTime)}&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * @param  rules                    {@code Rule[]} Rules that are to be checked.
	 * @throws IllegalArgumentException if the given rules are not unique.
	 */
	private static void validateRules(Rule[] rules) {
<span class="fc bfc" id="L431" title="All 2 branches covered.">		if (!Util.areRulesUnique(rules))</span>
<span class="fc" id="L432">			throw new IllegalArgumentException(&quot;The given rules are not unique.&quot; + &quot; Only unique rules can be used.&quot;);</span>

		/* All rules need to have the same reference window */
<span class="fc bfc" id="L435" title="All 2 branches covered.">		for (int i = 1; i &lt; rules.length; i++) {</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">			if (!rules[i].getStartOfReferenceWindow().isEqual(rules[i - 1].getStartOfReferenceWindow())</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">			        || !rules[i].getEndOfReferenceWindow().isEqual(rules[i - 1].getEndOfReferenceWindow())) {</span>
<span class="fc" id="L438">				throw new IllegalArgumentException(&quot;All rules need to have the same reference window but rules at&quot;</span>
				        + &quot; position &quot; + (i - 1) + &quot; and &quot; + i + &quot; differ.&quot;);
			}
		}

<span class="fc" id="L443">	}</span>

	/**
	 * ====================================================================== OVERRIDES
	 * ======================================================================
	 */

	/**
	 * A hash code for this SubSystem.
	 */
	@GeneratedCode
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		long temp;
		temp = Double.doubleToLongBits(baseScale);
		result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
		result = prime * result + ((baseValue == null) ? 0 : baseValue.hashCode());
		temp = Double.doubleToLongBits(capital);
		result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
		result = prime * result + Arrays.hashCode(combinedForecasts);
		result = prime * result + ((diversificationMultiplier == null) ? 0 : diversificationMultiplier.hashCode());
		result = prime * result + Arrays.hashCode(rules);
		return result;
	}

	/**
	 * Checks if this SubSystem is equal to another SubSystem.
	 */
	@GeneratedCode
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		SubSystem other = (SubSystem) obj;
		if (Double.doubleToLongBits(baseScale) != Double.doubleToLongBits(other.baseScale))
			return false;
		if (baseValue == null) {
			if (other.baseValue != null)
				return false;
		} else if (!baseValue.equals(other.baseValue))
			return false;
		if (Double.doubleToLongBits(capital) != Double.doubleToLongBits(other.capital))
			return false;
		if (!Arrays.equals(combinedForecasts, other.combinedForecasts))
			return false;
		if (diversificationMultiplier == null) {
			if (other.diversificationMultiplier != null)
				return false;
		} else if (!diversificationMultiplier.equals(other.diversificationMultiplier))
			return false;
		if (!Arrays.equals(rules, other.rules))
			return false;
		return true;
	}

	/**
	 * Outputs the fields of this SubSystem as a {@code String}.
	 */
	@GeneratedCode
	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append(&quot;SubSystem [baseValue=&quot;);
		builder.append(baseValue);
		builder.append(&quot;, rules=&quot;);
		builder.append(Arrays.toString(rules));
		builder.append(&quot;, diversificationMultiplier=&quot;);
		builder.append(diversificationMultiplier);
		builder.append(&quot;, capital=&quot;);
		builder.append(capital);
		builder.append(&quot;, combinedForecasts=&quot;);
		builder.append(Arrays.toString(combinedForecasts));
		builder.append(&quot;, baseScale=&quot;);
		builder.append(baseScale);
		builder.append(&quot;]&quot;);
		return builder.toString();
	}

	/**
	 * ====================================================================== GETTERS AND SETTERS
	 * ======================================================================
	 */

	/**
	 * Get the {@link BaseValue} for this subsystem.
	 * 
	 * @return baseValue SubSystem
	 */
	public BaseValue getBaseValue() {
<span class="fc" id="L538">		return baseValue;</span>
	}

	/**
	 * Set the {@link BaseValue} for this subsystem.
	 * 
	 * @param baseValue the baseValue to set
	 */
	private void setBaseValue(BaseValue baseValue) {
<span class="fc" id="L547">		this.baseValue = baseValue;</span>
<span class="fc" id="L548">	}</span>

	/**
	 * Get the rules for this subsystem.
	 * 
	 * @return rules SubSystem
	 */
	public Rule[] getRules() {
<span class="fc" id="L556">		return rules;</span>
	}

	/**
	 * Set the rules for this subsystem.
	 * 
	 * @param rules the rules to set
	 */
	public void setRules(Rule[] rules) {
<span class="fc" id="L565">		this.rules = rules;</span>
<span class="fc" id="L566">	}</span>

	/**
	 * Get the {@link DiversificationMultiplier} for this subsystem.
	 * 
	 * @return diversificationMultiplier SubSystem
	 */
	public DiversificationMultiplier getDiversificationMultiplier() {
<span class="fc" id="L574">		return diversificationMultiplier;</span>
	}

	/**
	 * Set the {@link DiversificationMultiplier} for this subsystem.
	 * 
	 * @param diversificationMultiplier the diversificationMultiplier to set
	 */
	private void setDiversificationMultiplier(DiversificationMultiplier diversificationMultiplier) {
<span class="fc" id="L583">		this.diversificationMultiplier = diversificationMultiplier;</span>
<span class="fc" id="L584">	}</span>

	/**
	 * Get the capital for this subsystem.
	 * 
	 * @return capital SubSystem
	 */
	public double getCapital() {
<span class="fc" id="L592">		return capital;</span>
	}

	/**
	 * Set the capital for this subsystem.
	 * 
	 * @param capital the capital to set
	 */
	private void setCapital(double capital) {
<span class="fc" id="L601">		this.capital = capital;</span>
<span class="fc" id="L602">	}</span>

	/**
	 * Get the combined forecasts for this subsystem.
	 * 
	 * @return combinedForecasts SubSystem
	 */
	public ValueDateTupel[] getCombinedForecasts() {
<span class="fc" id="L610">		return combinedForecasts;</span>
	}

	/**
	 * Set the combined forecasts for this subsystem.
	 * 
	 * @param combinedForecasts the combinedForecasts to set
	 */
	public void setCombinedForecasts(ValueDateTupel[] combinedForecasts) {
<span class="fc" id="L619">		this.combinedForecasts = combinedForecasts;</span>
<span class="fc" id="L620">	}</span>

	/**
	 * Get the base scale for this subsystem.
	 * 
	 * @return baseScale SubSystem
	 */
	public double getBaseScale() {
<span class="fc" id="L628">		return baseScale;</span>
	}

	/**
	 * Set the base scale for this subsystem.
	 * 
	 * @param baseScale the baseScale to set
	 */
	public void setBaseScale(double baseScale) {
<span class="fc" id="L637">		this.baseScale = baseScale;</span>
<span class="fc" id="L638">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
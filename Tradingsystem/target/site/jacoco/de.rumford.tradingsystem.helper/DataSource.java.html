<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataSource.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tradingsystem</a> &gt; <a href="index.source.html" class="el_package">de.rumford.tradingsystem.helper</a> &gt; <span class="el_source">DataSource.java</span></div><h1>DataSource.java</h1><pre class="source lang-java linenums">package de.rumford.tradingsystem.helper;

import java.io.*;
import java.time.LocalDateTime;
import java.util.regex.Pattern;

import org.apache.commons.lang3.ArrayUtils;

/**
 * The DataSource provides course value data from a given data source.
 * 
 * @author Max Rumford
 */
public class DataSource {

	/**
	 * Don't let anyone instantiate this class.
	 */
	private DataSource() {
	}

	/**
	 * Reads the data from a given CSV path. Assumes the following &quot;columns&quot;: Date, Time, value. Depending on the
	 * formatting of the CSV file the corresponding {@link CsvFormat} has to be passed. The underlying enumeration is
	 * not final and can be altered to suit the user's needs.
	 * &lt;p&gt;
	 * The CSV file to be parsed is expected not to have column headings. If so, the values of the first row might not
	 * be parsed and an IllegalArgumentException as explained below might be thrown. If the row can be parsed it will
	 * most likely not contain any useful information and might result in incorrect calculation results. The CSV file
	 * should always be cleared of headings.
	 * 
	 * @param  sourcePath               {@code String} The path to the CSV file to be read.
	 * @param  format                   {@link CsvFormat} The format of the CSV file.
	 * @return                          {@code ValueDateTupel[]} An array of {@link ValueDateTupel} representing the
	 *                                  read data.
	 * @throws FileNotFoundException    if the FileReader can not find a file for the given {@code sourcePath}.
	 * @throws IOException              if the given {@code sourcePath} cannot be properly resolved to an actual file.
	 * @throws IllegalArgumentException if the given path is invalid.
	 * @throws IllegalArgumentException if any of the rows in the read CSV file does not contain exactly 3 columns.
	 */
	public static ValueDateTupel[] getDataFromCsv(String sourcePath, CsvFormat format) throws IOException {
		File file;
		try {
<span class="fc" id="L44">			file = new File(sourcePath);</span>
<span class="fc" id="L45">		} catch (Exception e) {</span>
<span class="fc" id="L46">			throw new IllegalArgumentException(&quot;The given path cannot be processed&quot;);</span>
<span class="fc" id="L47">		}</span>

<span class="fc bfc" id="L49" title="All 2 branches covered.">		if (!file.exists())</span>
<span class="fc" id="L50">			throw new IOException(&quot;Given source path does not point to an existing destination&quot;);</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">		if (!file.isFile())</span>
<span class="fc" id="L52">			throw new IOException(&quot;Given source path does not point to a file&quot;);</span>
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">		if (!file.canRead())</span>
<span class="nc" id="L54">			throw new IOException(&quot;Given file path cannot be read&quot;);</span>

<span class="fc" id="L56">		try (BufferedReader br = new BufferedReader(new FileReader(file))) {</span>
			String line;

<span class="fc" id="L59">			ValueDateTupel[] returnValues = ValueDateTupel.createEmptyArray();</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">			while ((line = br.readLine()) != null) {</span>
				/* Extract the fields into separate Strings */
<span class="fc" id="L62">				String[] columns = line.split(Pattern.quote(format.getFieldSeparator()));</span>

<span class="fc bfc" id="L64" title="All 2 branches covered.">				if (columns.length != 3) {</span>
<span class="fc" id="L65">					throw new IllegalArgumentException(</span>
					        &quot;The passed CSV does not have an appropriate number of&quot; + &quot; columns&quot;);
				}

				/*
				 * Parse the first and second field (date, time) into a LocalDateTime instance
				 */
<span class="fc" id="L72">				String[] dateAndTimeStrings = new String[2];</span>
<span class="fc" id="L73">				System.arraycopy(columns, 0, dateAndTimeStrings, 0, 2);</span>
				LocalDateTime localDateTime;
				double value;
<span class="fc" id="L76">				localDateTime = parseLocalDateTime(dateAndTimeStrings, format);</span>

				/* Pass the third field (course value) into a double */
<span class="fc" id="L79">				String[] valueStrings = new String[1];</span>
<span class="fc" id="L80">				System.arraycopy(columns, 2, valueStrings, 0, 1);</span>
<span class="fc" id="L81">				value = parseCourseValue(valueStrings, format);</span>

<span class="fc" id="L83">				ValueDateTupel newElement = new ValueDateTupel(localDateTime, value);</span>

<span class="fc" id="L85">				returnValues = ArrayUtils.add(returnValues, newElement);</span>
<span class="fc" id="L86">			}</span>
<span class="fc" id="L87">			return returnValues;</span>
		}
	}

	/**
	 * Parse the given columns {date, time} into a {@link LocalDateTime} instance. Expects an array of Strings of length
	 * 2.
	 * 
	 * @param  columns                  {@code String[]} The columns containing the String representing date and time.
	 * @param  format                   {@link CsvFormat} The {@link CsvFormat} representing the given CSV file.
	 * @return                          {@link LocalDateTime} representation of the passed {date, time} columns.
	 * @throws IllegalArgumentException If there are not exactly two columns in the passed {@code String[]}.
	 * @throws IllegalArgumentException If the date pattern could not be recognized in subroutine
	 *                                  {@link #evaluateDatePattern( CsvFormat)}.
	 * @throws IllegalArgumentException If the given date values cannot be parsed to Integers.
	 * @throws IllegalArgumentException If the given time values cannot be parsed to Integers.
	 * @throws IllegalArgumentException If the given date and time values cannot be parsed to {@link LocalDateTime}}.
	 */
	private static LocalDateTime parseLocalDateTime(String[] columns, CsvFormat format) {
		/* Extract the relevant date values */
<span class="fc" id="L107">		String[] date = columns[0].split(Pattern.quote(format.getDateSeparator()));</span>

		/* Evaluate the date pattern */
<span class="fc" id="L110">		int[] datePositions = evaluateDatePattern(format);</span>

		int dayOfMonth;
		int month;
		int year;
		try {
<span class="fc" id="L116">			dayOfMonth = Integer.parseInt(date[datePositions[0]]);</span>
<span class="fc" id="L117">			month = Integer.parseInt(date[datePositions[1]]);</span>
<span class="fc" id="L118">			year = Integer.parseInt(date[datePositions[2]]);</span>
<span class="fc" id="L119">		} catch (NumberFormatException e) {</span>
<span class="fc" id="L120">			throw new IllegalArgumentException(&quot;The date values of the read CSV file cannot be parsed into&quot;</span>
			        + &quot; numbers. Failing value &gt;&quot; + columns[0] + &quot;&lt;&quot;);
		}
		/*
		 * Catch Exception so BufferedReader can be closed (in calling method) on unknown Exceptions to avoid memory
		 * leakage.
		 */
<span class="fc" id="L127">		catch (Exception e) {</span>
<span class="fc" id="L128">			throw e;</span>
<span class="fc" id="L129">		}</span>

		/* Extract the relevant time values */
<span class="fc" id="L132">		String[] time = columns[1].split(format.getTimeSeparator());</span>
		int hour;
		int minute;
		int second;
		try {
<span class="fc" id="L137">			hour = Integer.parseInt(time[0]);</span>
<span class="fc" id="L138">			minute = Integer.parseInt(time[1]);</span>
<span class="fc" id="L139">			second = Integer.parseInt(time[2]);</span>
<span class="fc" id="L140">		} catch (NumberFormatException e) {</span>
<span class="fc" id="L141">			throw new IllegalArgumentException(&quot;The time values of the read CSV file cannot be parsed into&quot;</span>
			        + &quot; numbers. Failing value &gt;&quot; + columns[1] + &quot;&lt;&quot;);
<span class="fc" id="L143">		}</span>

		LocalDateTime localDateTime;
		try {
<span class="fc" id="L147">			localDateTime = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second);</span>
<span class="fc" id="L148">		} catch (Exception e) {</span>
<span class="fc" id="L149">			throw new IllegalArgumentException(&quot;The date or time values of the read CSV file cannot be parsed&quot;</span>
			        + &quot; into a LocalDateTime instance. Failing values &gt;&quot; + columns[0] + &quot;&lt; and &gt;&quot; + columns[1] + &quot;&lt;.&quot;);
<span class="fc" id="L151">		}</span>
<span class="fc" id="L152">		return localDateTime;</span>
	}

	/**
	 * Evaluate the date pattern from the given {@link CsvFormat}. If {@link CsvFormat} is extended this method has to
	 * be overridden, else an {@link IllegalArgumentException} will be thrown due to an unknown format.
	 * 
	 * @param  format                   {@link CsvFormat} Format of the CSV file to be parsed.
	 * @return                          {@code int[]} containing the position of {day, month, year} values inside the
	 *                                  date field of the given CSV.
	 * @throws IllegalArgumentException if the date given date pattern is not recognized.
	 */
	public static int[] evaluateDatePattern(CsvFormat format) {
		int monthPosition;
		int dayPosition;
		int yearPosition;
<span class="fc bfc" id="L168" title="All 2 branches covered.">		if (format.getMonthDayOrder() == DateOrder.DAY_MONTH_YEAR) {</span>
<span class="fc" id="L169">			dayPosition = 0;</span>
<span class="fc" id="L170">			monthPosition = 1;</span>
<span class="fc" id="L171">			yearPosition = 2;</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">		} else if (format.getMonthDayOrder() == DateOrder.MONTH_DAY_YEAR) {</span>
<span class="fc" id="L173">			dayPosition = 1;</span>
<span class="fc" id="L174">			monthPosition = 0;</span>
<span class="fc" id="L175">			yearPosition = 2;</span>
		} else {
<span class="fc" id="L177">			dayPosition = 2;</span>
<span class="fc" id="L178">			monthPosition = 1;</span>
<span class="fc" id="L179">			yearPosition = 0;</span>
		}

<span class="fc" id="L182">		int[] returnArray = { dayPosition, monthPosition, yearPosition };</span>

<span class="fc" id="L184">		return returnArray;</span>
	}

	/**
	 * Parse the course value String into a {@code double} representing its values.
	 * 
	 * @param  columns                  {@code String[]} The String representation of the CSV column containing the
	 *                                  value.
	 * @param  format                   {@link CsvFormat} Format the CSV file is in.
	 * @return                          {@code double} The parsed value.
	 * @throws IllegalArgumentException if the passed String cannot be properly parsed
	 */
	private static double parseCourseValue(String[] columns, CsvFormat format) {
<span class="fc" id="L197">		String valueString = columns[0];</span>
		/* Eliminate thousands separator from String */
<span class="fc bfc" id="L199" title="All 2 branches covered.">		if (valueString.contains(format.getThousandsSeparator())) {</span>
<span class="fc" id="L200">			valueString = valueString.replaceAll(Pattern.quote(format.getThousandsSeparator()), &quot;&quot;);</span>
		}
		/* Replace non-US decimal points with US decimal points */
<span class="fc bfc" id="L203" title="All 2 branches covered.">		if (!format.getDecimalPoint().equals(CsvFormat.US.getDecimalPoint())) {</span>
<span class="fc" id="L204">			valueString = valueString.replace(format.getDecimalPoint(), CsvFormat.US.getDecimalPoint());</span>
		}

		double value;
		/*
		 * At this point all hindering sings have been eradicated from the String
		 */
		try {
<span class="fc" id="L212">			value = Double.parseDouble(valueString);</span>
<span class="fc" id="L213">		} catch (NumberFormatException e) {</span>
<span class="fc" id="L214">			throw new IllegalArgumentException(&quot;The course value &gt;&quot; + columns[0] + &quot;&lt; cannot be parsed&quot;);</span>
<span class="nc" id="L215">		} catch (Exception e) {</span>
<span class="nc" id="L216">			throw e;</span>
<span class="fc" id="L217">		}</span>

<span class="fc" id="L219">		return value;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
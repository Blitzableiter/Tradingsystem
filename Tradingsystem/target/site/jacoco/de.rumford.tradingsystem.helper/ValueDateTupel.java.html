<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ValueDateTupel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Tradingsystem</a> &gt; <a href="index.source.html" class="el_package">de.rumford.tradingsystem.helper</a> &gt; <span class="el_source">ValueDateTupel.java</span></div><h1>ValueDateTupel.java</h1><pre class="source lang-java linenums">package de.rumford.tradingsystem.helper;

import java.time.LocalDateTime;
import java.time.chrono.ChronoLocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.TreeSet;

import org.apache.commons.lang3.ArrayUtils;

import de.rumford.tradingsystem.BaseValue;

/**
 * A ValueDateTupel represents a decimal value at a given point in time.
 * &lt;p&gt;
 * The ValueDateTupel is the most used helper class in this library. It consists of a LocalDateTime value representing a
 * point in time, and of a double, representing any kind of decimal value associated with the aforementioned point in
 * time. By using LocalDateTime (an not just a class representing Date values) intraday usage is possible.
 * &lt;p&gt;
 * The ValueDateTupel brings a lot of static method used throughout the entire library. Most of these methods deal with
 * arrays or larger structures of ValueDateTupel, as the instance of ValueDateTupel by itself does not have many
 * limitations.
 * 
 * @author Max Rumford
 */
public class ValueDateTupel {

	/* The value to be represented. */
	private double value;
	/* The datetime to be represented. */
	private LocalDateTime date;

	static final String MESSAGE_ARRAY_MUST_NOT_BE_NULL = &quot;Given array must not be null&quot;;
	static final String MESSAGE_VALUE_MUST_NOT_BE_NULL = &quot;Given value must not be null&quot;;

	/**
	 * Creates a new {@link ValueDateTupel} instance using the given LocaDateTime and double.
	 * 
	 * @param date  {@link LocalDateTime} The dateTime to be set for this {@link ValueDateTupel}
	 * @param value {@code double} The value to be set for this {@link ValueDateTupel}
	 */
<span class="fc" id="L43">	public ValueDateTupel(LocalDateTime date, double value) {</span>
<span class="fc" id="L44">		this.setDate(date);</span>
<span class="fc" id="L45">		this.setValue(value);</span>
<span class="fc" id="L46">	}</span>

	/**
	 * Adds a given {@link ValueDateTupel} to the given array of {@link ValueDateTupel} at the given position. Returns
	 * the given array extended with the given single value.
	 * 
	 * @param  valueDateTupels          {@code ValueDateTupel[]} Array to be extended.
	 * @param  vdtToBeAdded             {@link ValueDateTupel} Value to be added.
	 * @param  position                 {@code int} Position the given value shall be put into.
	 * @return                          {@code ValueDateTupel[]} The extended array.
	 * @throws IllegalArgumentException If the given array is null.
	 * @throws IllegalArgumentException If the given value to be added is null.
	 * @throws IllegalArgumentException If the position is negative.
	 * @throws IllegalArgumentException If the given position is greater than the length of the given array.
	 */
	public static ValueDateTupel[] addOneAt(ValueDateTupel[] valueDateTupels, ValueDateTupel vdtToBeAdded,
	        int position) {
<span class="fc bfc" id="L63" title="All 2 branches covered.">		if (valueDateTupels == null)</span>
<span class="fc" id="L64">			throw new IllegalArgumentException(MESSAGE_ARRAY_MUST_NOT_BE_NULL);</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">		if (vdtToBeAdded == null)</span>
<span class="fc" id="L66">			throw new IllegalArgumentException(MESSAGE_VALUE_MUST_NOT_BE_NULL);</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">		if (position &lt; 0)</span>
<span class="fc" id="L68">			throw new IllegalArgumentException(&quot;Cannot add a value at position &lt; 0. Given position is &quot; + position);</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">		if (position &gt; valueDateTupels.length)</span>
<span class="fc" id="L70">			throw new IllegalArgumentException(&quot;Cannot add a value at position &gt; &quot; + valueDateTupels.length</span>
			        + &quot;. Given position is &quot; + position + &quot;.&quot;);

<span class="fc" id="L73">		ValueDateTupel[] extendedArray = ValueDateTupel.createEmptyArray(valueDateTupels.length + 1);</span>

		/* Add new ValueDateTupel at the beginning of the given array. */
<span class="fc bfc" id="L76" title="All 2 branches covered.">		if (position == 0) {</span>
<span class="fc" id="L77">			extendedArray[position] = vdtToBeAdded;</span>
<span class="fc" id="L78">			System.arraycopy(valueDateTupels, 0, extendedArray, 1, valueDateTupels.length);</span>
<span class="fc" id="L79">			return extendedArray;</span>
		}
		/* Add new ValueDateTupel at the end of the given array. */
<span class="fc bfc" id="L82" title="All 2 branches covered.">		if (position == valueDateTupels.length) {</span>
<span class="fc" id="L83">			System.arraycopy(valueDateTupels, 0, extendedArray, 0, valueDateTupels.length);</span>
<span class="fc" id="L84">			extendedArray[position] = vdtToBeAdded;</span>
<span class="fc" id="L85">			return extendedArray;</span>
		}
		/*
		 * This code is only reached, when the new ValueDateTupel shall not be added at end or at beginning.
		 */
		/* Add all values prior to the new ValueDateTupel */
<span class="fc" id="L91">		System.arraycopy(valueDateTupels, 0, extendedArray, 0, position);</span>
		/* Add new ValueDateTupel at the given position. */
<span class="fc" id="L93">		extendedArray[position] = vdtToBeAdded;</span>
		/* Add all values subsequent to the new ValueDateTupel */
<span class="fc" id="L95">		System.arraycopy(valueDateTupels, position, extendedArray, position + 1, valueDateTupels.length - position);</span>
<span class="fc" id="L96">		return extendedArray;</span>
	}

	/**
	 * Add missing {@link LocalDateTime} values to all given {@code ValueDateTupel[]}. The corresponding value will be
	 * set to average the values of its direct predecessor and successor.
	 * &lt;p&gt;
	 * If there are multiple {@link LocalDateTime} missing in a row, all of those will get the average value of the last
	 * position before and the first position after all missing values.
	 * &lt;p&gt;
	 * If the missing {@link LocalDateTime} would be the first value in the new array, its value will be set to match
	 * the previously first one.
	 * &lt;p&gt;
	 * If the missing {@link LocalDateTime} would be the last value in the new array, its value will be set to match the
	 * previously last one.
	 * 
	 * @param  valueDateTupels          {@code ValueDateTupel[][]} Array of arrays of {@link ValueDateTupel} whose
	 *                                  {@link LocalDateTime} shall be aligned.
	 * @return                          {@code ValueDateTupel[][]} Array of arrays of {@link ValueDateTupel} with now
	 *                                  aligned {@link LocalDateTime} values.
	 * @throws IllegalArgumentException If the given array of arrays is null.
	 * @throws IllegalArgumentException If the given array of arrays contains null.
	 * @throws IllegalArgumentException If any array of the given array of arrays contains null.
	 * @throws IllegalArgumentException If the given array contains an array of {@link ValueDateTupel} not sorted in
	 *                                  ascending order.
	 * @throws IllegalArgumentException If the one of the given arrays contains only {@link Double#NaN}.
	 */
	public static ValueDateTupel[][] alignDates(ValueDateTupel[][] valueDateTupels) {
<span class="fc bfc" id="L124" title="All 2 branches covered.">		if (valueDateTupels == null)</span>
<span class="fc" id="L125">			throw new IllegalArgumentException(&quot;Given array of arrays must not be null&quot;);</span>

		/* TreeSet (unique and sorted) of all dates in all valueDateTupel[] */
<span class="fc" id="L128">		TreeSet&lt;LocalDateTime&gt; uniqueSortedDates = getUniqueDates(valueDateTupels);</span>

		/* Loop over all rows */
<span class="fc bfc" id="L131" title="All 2 branches covered.">		for (int rowIndex = 0; rowIndex &lt; valueDateTupels.length; rowIndex++) {</span>

			try {
				/* Validate if the row contains at least one suitable value. */
<span class="fc" id="L135">				Validator.validateRow(valueDateTupels[rowIndex]);</span>
<span class="nc" id="L136">			} catch (IllegalArgumentException e) {</span>
<span class="nc" id="L137">				throw new IllegalArgumentException(&quot;Row at position &quot; + rowIndex + &quot; is not valid.&quot;, e);</span>
<span class="fc" id="L138">			}</span>

			/*
			 * If the row's length equals the length of uniqueSortedDates no Value has to be added as it already
			 * contains all dateTimes.
			 */
<span class="fc bfc" id="L144" title="All 2 branches covered.">			if (valueDateTupels[rowIndex].length == uniqueSortedDates.size())</span>
<span class="fc" id="L145">				continue;</span>

			/* Enhance current row by missing LocalDateTime values. */
<span class="fc" id="L148">			valueDateTupels[rowIndex] = enhanceRowByNaNs(valueDateTupels[rowIndex], uniqueSortedDates);</span>

			/* Replace all values of Double.NaN by real values. */
<span class="fc" id="L151">			valueDateTupels[rowIndex] = replaceNansByValues(valueDateTupels[rowIndex]);</span>

		}
<span class="fc" id="L154">		return valueDateTupels;</span>
	}

	/**
	 * Check if the given {@link ValueDateTupel} can be found in the given array of {@link ValueDateTupel}. Will only
	 * find exact matches.
	 * 
	 * @param  valueDateTupels {@code ValueDateTupel[]} Array to be searched in.
	 * @param  vdtToBeFound    {@link ValueDateTupel} Value to be searched for.
	 * @return                 {@code boolean} True, if the given value can be found in the given array, false
	 *                         otherwise.
	 */
	public static boolean contains(ValueDateTupel[] valueDateTupels, ValueDateTupel vdtToBeFound) {
<span class="fc bfc" id="L167" title="All 2 branches covered.">		if (valueDateTupels == null)</span>
<span class="fc" id="L168">			throw new IllegalArgumentException(MESSAGE_ARRAY_MUST_NOT_BE_NULL);</span>
<span class="fc" id="L169">		List&lt;ValueDateTupel&gt; list = new ArrayList&lt;&gt;(Arrays.asList(valueDateTupels));</span>
<span class="fc" id="L170">		return list.contains(vdtToBeFound);</span>
	}

	/**
	 * Check if the given array of {@link ValueDateTupel} contains the given {@link LocalDateTime}.
	 * 
	 * @param  valueDateTupels          {@code ValueDateTupel[]} Array to be searched in.
	 * @param  dtToBeFound              {@link LocalDateTime} Value to be searched for.
	 * @return                          {@code boolean} True, if the given value can be found inside the given array,
	 *                                  false otherwise.
	 * @throws IllegalArgumentException If the given array of {@link ValueDateTupel} is null.
	 * @throws IllegalArgumentException If the given {@link LocalDateTime} is null.
	 */
	public static boolean containsDate(ValueDateTupel[] valueDateTupels, LocalDateTime dtToBeFound) {
<span class="fc bfc" id="L184" title="All 2 branches covered.">		if (valueDateTupels == null)</span>
<span class="fc" id="L185">			throw new IllegalArgumentException(MESSAGE_ARRAY_MUST_NOT_BE_NULL);</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">		if (dtToBeFound == null)</span>
<span class="fc" id="L187">			throw new IllegalArgumentException(MESSAGE_VALUE_MUST_NOT_BE_NULL);</span>
		/* Load all values from the given array into an ArrayList. */
<span class="fc" id="L189">		List&lt;LocalDateTime&gt; list = new ArrayList&lt;&gt;(Arrays.asList(ValueDateTupel.getDates(valueDateTupels)));</span>
		/* Utilize the generic contains method on ArrayList. */
<span class="fc" id="L191">		return list.contains(dtToBeFound);</span>
	}

	/**
	 * Creates an empty array of {@link ValueDateTupel}.
	 * 
	 * @return {@code ValueDateTupel[]} An Empty array of {@link ValueDateTupel}.
	 */
	public static ValueDateTupel[] createEmptyArray() {
<span class="fc" id="L200">		return ValueDateTupel.createEmptyArray(0);</span>
	}

	/**
	 * Creates an empty array of {@link ValueDateTupel} with the given length.
	 * 
	 * @param  length {@code int} Length the new array should have.
	 * @return        {@code ValueDateTupel[]} An Empty array of {@link ValueDateTupel}.
	 */
	public static ValueDateTupel[] createEmptyArray(int length) {
<span class="fc" id="L210">		return new ValueDateTupel[length];</span>
	}

	/**
	 * Check if the {@link BaseValue} instance contains the given {@link LocalDateTime} in its values. Returns the
	 * containing {@link ValueDateTupel} if so, returns {@code null} otherwise.
	 * 
	 * @param  valueDateTupels {@code ValueDateTupel[]} The array of {@link ValueDateTupel} to be searched through.
	 * @param  dtToBeFound     {@link LocalDateTime} Value to be found inside the {@link BaseValue} values.
	 * @return                 {@link ValueDateTupel} containing the given {@link LocalDateTime}. {@code null} if the
	 *                         given {@link LocalDateTime} cannot be found.
	 */
	public static ValueDateTupel getElement(ValueDateTupel[] valueDateTupels, LocalDateTime dtToBeFound) {
		/* Check if given array is null */
<span class="fc bfc" id="L224" title="All 2 branches covered.">		if (valueDateTupels == null)</span>
<span class="fc" id="L225">			throw new IllegalArgumentException(MESSAGE_ARRAY_MUST_NOT_BE_NULL);</span>

<span class="fc bfc" id="L227" title="All 2 branches covered.">		if (dtToBeFound == null)</span>
<span class="fc" id="L228">			throw new IllegalArgumentException(MESSAGE_VALUE_MUST_NOT_BE_NULL);</span>

<span class="fc bfc" id="L230" title="All 2 branches covered.">		for (ValueDateTupel value : valueDateTupels) {</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">			if (value.getDate().equals(dtToBeFound))</span>
<span class="fc" id="L232">				return value;</span>
		}
<span class="fc" id="L234">		return null;</span>
	}

	/**
	 * Get all elements between two given DateTimes (inclusive) from the given array. If null is passed for either
	 * LocalDateTime, the representing border will be set to the boundaries of the given array.
	 * 
	 * @param  valueDateTupels {@code ValueDateTupel[]} The base array.
	 * @param  dtFrom          {@link LocalDateTime} The first DateTime to be included. If null, all values up until
	 *                         dtTo will be given.
	 * @param  dtTo            {@link LocalDateTime} The last DateTime to be included. If null, all values starting from
	 *                         dtFrom will be given.
	 * @return                 {@code ValueDateTupel[]} The found elements. null, if dtFrom or dtTo cannot be found in
	 *                         the given array.
	 */
	public static ValueDateTupel[] getElements(ValueDateTupel[] valueDateTupels, LocalDateTime dtFrom,
	        LocalDateTime dtTo) {
		int positionFrom;
		int positionTo;
		/*
		 * Get the position indices of the given LocalDateTime values. If null is passed, set the positions to be the
		 * respective boundaries of the given array.
		 */
<span class="fc bfc" id="L257" title="All 2 branches covered.">		if (dtFrom == null) {</span>
<span class="fc" id="L258">			positionFrom = 0;</span>
		} else {
<span class="fc" id="L260">			positionFrom = ValueDateTupel.getPosition(valueDateTupels, dtFrom);</span>
		}
<span class="fc bfc" id="L262" title="All 2 branches covered.">		if (dtTo == null) {</span>
<span class="fc" id="L263">			positionTo = valueDateTupels.length - 1;</span>
		} else {
<span class="fc" id="L265">			positionTo = ValueDateTupel.getPosition(valueDateTupels, dtTo);</span>
		}

		/*
		 * If the given LocalDateTime values cannot be found in the given array return null.
		 */
<span class="fc bfc" id="L271" title="All 4 branches covered.">		if (positionFrom == Integer.MIN_VALUE || positionTo == Integer.MIN_VALUE)</span>
<span class="fc" id="L272">			return null;</span>

<span class="fc" id="L274">		ValueDateTupel[] elements = {};</span>
		/* Add all elements between the two found positions ... */
<span class="fc bfc" id="L276" title="All 2 branches covered.">		for (int i = positionFrom; i &lt;= positionTo; i++) {</span>
<span class="fc" id="L277">			elements = ArrayUtils.add(elements, valueDateTupels[i]);</span>
		}
		/* ... and return them. */
<span class="fc" id="L280">		return elements;</span>
	}

	/**
	 * Get all {@link LocalDateTime} from an array of {@link ValueDateTupel}.
	 * 
	 * @param  valueDateTupels          {@code ValueDateTupel[]} An array of {@link ValueDateTupel}}.
	 * @return                          {@code LocalDateTime[]} An array of {@link LocalDateTime} of the given
	 *                                  {@code ValueDateTupel[]}. Returns an empty array if the given array is empty.
	 * @throws IllegalArgumentException if the given array is null.
	 */
	public static LocalDateTime[] getDates(ValueDateTupel[] valueDateTupels) {
<span class="fc bfc" id="L292" title="All 2 branches covered.">		if (valueDateTupels == null)</span>
<span class="fc" id="L293">			throw new IllegalArgumentException(MESSAGE_ARRAY_MUST_NOT_BE_NULL);</span>

<span class="fc" id="L295">		LocalDateTime[] values = {};</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">		for (ValueDateTupel tupel : valueDateTupels) {</span>
<span class="fc" id="L297">			values = ArrayUtils.add(values, tupel.getDate());</span>
		}
<span class="fc" id="L299">		return values;</span>
	}

	/**
	 * Finds the position of a given {@link LocalDateTime} in a given array of {@link ValueDateTupel}.
	 * 
	 * @param  valueDateTupels {@code ValueDateTupel[]} The array to be searched.
	 * @param  dtToBeFound     {@link LocalDateTime} The value to be found.
	 * @return                 {@code int} The position the given LocalDateTime was found. If the given LocalDateTime
	 *                         cannot be found, Integer.MIN_VALUE is returned. If the given array's length is 0
	 *                         Integer.MIN_VALUE is returned.
	 */
	public static int getPosition(ValueDateTupel[] valueDateTupels, LocalDateTime dtToBeFound) {
<span class="fc" id="L312">		final int defaultReturnValue = Integer.MIN_VALUE;</span>

		/* Check if given array is null */
<span class="fc bfc" id="L315" title="All 2 branches covered.">		if (valueDateTupels == null)</span>
<span class="fc" id="L316">			throw new IllegalArgumentException(MESSAGE_ARRAY_MUST_NOT_BE_NULL);</span>

		/*
		 * If there are no values in the given array return the default return value.
		 */
<span class="fc bfc" id="L321" title="All 2 branches covered.">		if (valueDateTupels.length == 0)</span>
<span class="fc" id="L322">			return defaultReturnValue;</span>

		/* Check if given LocalDateTime is null */
<span class="fc bfc" id="L325" title="All 2 branches covered.">		if (dtToBeFound == null)</span>
<span class="fc" id="L326">			throw new IllegalArgumentException(MESSAGE_VALUE_MUST_NOT_BE_NULL);</span>

		/*
		 * if the given LocalDateTime is in the given array, return its position.
		 */
<span class="fc bfc" id="L331" title="All 2 branches covered.">		for (int i = 0; i &lt; valueDateTupels.length; i++) {</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">			if (valueDateTupels[i].getDate().equals(dtToBeFound))</span>
<span class="fc" id="L333">				return i;</span>
		}

		/* Otherwise, return Integer.MIN_VALUE */
<span class="fc" id="L337">		return defaultReturnValue;</span>
	}

	/**
	 * Get all values from an array of {@link ValueDateTupel}.
	 * 
	 * @param  valueDateTupels          {@code ValueDateTupel[]} An array of {@link ValueDateTupel}}.
	 * @return                          {@code double[]} An array of values of the given {@code ValueDateTupel[]}.
	 *                                  Returns an empty array if the given array is empty.
	 * @throws IllegalArgumentException if the given array is null.
	 */
	public static double[] getValues(ValueDateTupel[] valueDateTupels) {
<span class="fc bfc" id="L349" title="All 2 branches covered.">		if (valueDateTupels == null)</span>
<span class="fc" id="L350">			throw new IllegalArgumentException(MESSAGE_ARRAY_MUST_NOT_BE_NULL);</span>

<span class="fc" id="L352">		double[] values = {};</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">		for (ValueDateTupel tupel : valueDateTupels)</span>
<span class="fc" id="L354">			values = ArrayUtils.add(values, tupel.getValue());</span>
<span class="fc" id="L355">		return values;</span>
	}

	/**
	 * Evaluate if the given array of {@link ValueDateTupel} is sorted in ascending order, i.e., if the value at
	 * position 0 has the lowest {@link LocalDateTime} value (implicit check) and all subsequent {@link ValueDateTupel}
	 * each have a {@link LocalDateTime} after ({@link LocalDateTime#isAfter(ChronoLocalDateTime)}) the previous one.
	 * &lt;p&gt;
	 * If two values have the same {@link LocalDateTime} false will be returned.
	 * 
	 * @param  valueDateTupels          {@code ValueDateTupel[]} array of {@link ValueDateTupel} to be checked for
	 *                                  ascending order.
	 * @return                          {@code boolean} False, if any date is not chronologically after its predecessor,
	 *                                  true if otherwise.
	 * @throws IllegalArgumentException If the given array is null.
	 * @throws IllegalArgumentException If the given array contains null values.
	 */
	public static boolean isSortedAscending(ValueDateTupel[] valueDateTupels) {
<span class="fc bfc" id="L373" title="All 2 branches covered.">		if (valueDateTupels == null)</span>
<span class="fc" id="L374">			throw new IllegalArgumentException(MESSAGE_ARRAY_MUST_NOT_BE_NULL);</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">		if (ValueDateTupel.contains(valueDateTupels, null))</span>
<span class="fc" id="L376">			throw new IllegalArgumentException(&quot;The given array must not contain any nulls&quot;);</span>

<span class="fc bfc" id="L378" title="All 2 branches covered.">		for (int i = 1; i &lt; valueDateTupels.length; i++) {</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">			if (!valueDateTupels[i].getDate().isAfter(valueDateTupels[i - 1].getDate())) {</span>
<span class="fc" id="L380">				return false;</span>
			}
		}
<span class="fc" id="L383">		return true;</span>
	}

	/**
	 * Evaluate if the given array of {@link ValueDateTupel} is sorted in descending order, i.e., if the value at
	 * position 0 has the highest {@link LocalDateTime} value (implicit check) and all subsequent {@link ValueDateTupel}
	 * each have a {@link LocalDateTime} before ({@link LocalDateTime#isBefore(ChronoLocalDateTime)}) the previous one.
	 * &lt;p&gt;
	 * If two values have the same {@link LocalDateTime} false will be returned.
	 * 
	 * @param  valueDateTupels          {@code ValueDateTupel[]} array of {@link ValueDateTupel} to be checked for
	 *                                  descending order.
	 * @return                          {@code boolean} False, if any date is not chronologically before its
	 *                                  predecessor, true if otherwise.
	 * @throws IllegalArgumentException If the given array is null.
	 * @throws IllegalArgumentException If the given array contains null values.
	 */
	public static boolean isSortedDescending(ValueDateTupel[] valueDateTupels) {
<span class="fc bfc" id="L401" title="All 2 branches covered.">		if (valueDateTupels == null)</span>
<span class="fc" id="L402">			throw new IllegalArgumentException(MESSAGE_ARRAY_MUST_NOT_BE_NULL);</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">		if (ValueDateTupel.contains(valueDateTupels, null))</span>
<span class="fc" id="L404">			throw new IllegalArgumentException(&quot;The given array must not contain any null LocalDateTime&quot;);</span>

<span class="fc bfc" id="L406" title="All 2 branches covered.">		for (int i = 1; i &lt; valueDateTupels.length; i++) {</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">			if (!valueDateTupels[i].getDate().isBefore(valueDateTupels[i - 1].getDate())) {</span>
<span class="fc" id="L408">				return false;</span>
			}
		}
<span class="fc" id="L411">		return true;</span>
	}

	/**
	 * Finds all {@link LocalDateTime} present in uniqueSortedDates but not in valueDateTupels and add them to the
	 * latter with a value of Double.NaN.
	 * 
	 * @param  valueDateTupels   {@code ValueDateTupel[]} The array of {@link ValueDateTupel} to be enhanced.
	 * @param  uniqueSortedDates {@code TreeSet&lt;LocalDateTime&gt;} A {@link TreeSet} of {@link LocalDateTime} containing
	 *                           all unique LocalDateTimes.
	 * @return                   {@code ValueDateTupel[]} valueDateTupels + all LocalDateTime additionally given by
	 *                           uniqueSortedDates. Array is sorted as by {@link #isSortedAscending(ValueDateTupel[])}.
	 */
	private static ValueDateTupel[] enhanceRowByNaNs(ValueDateTupel[] valueDateTupels,
	        TreeSet&lt;LocalDateTime&gt; uniqueSortedDates) {

		/*
		 * Load unique sorted dates into an ArrayList to have access to an index.
		 */
<span class="fc" id="L430">		List&lt;LocalDateTime&gt; uniqueSortedDatesList = new ArrayList&lt;&gt;(uniqueSortedDates);</span>

		/*
		 * Loop over all unique dateTimes to assess if they are in the current row. If not, missing dateTimes are added
		 * into the original arrays. Their value is set to Double.NaN
		 */
<span class="fc bfc" id="L436" title="All 2 branches covered.">		for (int fieldIndex = 0; fieldIndex &lt; uniqueSortedDates.size(); fieldIndex++) {</span>
<span class="fc" id="L437">			ValueDateTupel valueDateTupelToBeAdded = new ValueDateTupel(uniqueSortedDatesList.get(fieldIndex),</span>
			        Double.NaN);

<span class="fc bfc" id="L440" title="All 2 branches covered.">			if (fieldIndex &lt; valueDateTupels.length</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">			        &amp;&amp; uniqueSortedDatesList.get(fieldIndex).isEqual(valueDateTupels[fieldIndex].getDate())) {</span>

				/*
				 * Nothing has to be done, as we're not at the end of the list and the current LocalDateTime out of the
				 * list of unique values is already in the given row.
				 */
<span class="fc" id="L447">				continue;</span>
			}

<span class="fc" id="L450">			valueDateTupels = ValueDateTupel.addOneAt(valueDateTupels, valueDateTupelToBeAdded, fieldIndex);</span>
		}

<span class="fc" id="L453">		return valueDateTupels;</span>
	}

	/**
	 * Fills up a gap of NaN-values in a given array of {@link ValueDateTupel} with the average of the previously last
	 * and first next available non-NaN-value.
	 * 
	 * @param  valueDateTupels   {@code ValueDateTupel} Array of {@link ValueDateTupel} holding the values.
	 * @param  previousAvailable {@code int} Index of the last available non-NaN-value before the gap to be filled.
	 * @param  nextAvailable     {@code int} Index of the first available non-NaN-value after the gap to be filled.
	 * @return                   {@code ValueDateTupel} Array of {@link ValueDateTupel} with the gap filled.
	 */
	private static ValueDateTupel[] fillCenterValues(ValueDateTupel[] valueDateTupels, int previousAvailable,
	        int nextAvailable) {
		/*
		 * The value to be set to all missing values is the average of the last non-NaN before the NaNs and the first
		 * non-NaN after the NaNs. This is the case when the missing NaNs are not at the beginning or the end of the
		 * given array.
		 */
<span class="fc" id="L472">		double valueToBeSet = (valueDateTupels[previousAvailable].getValue()</span>
<span class="fc" id="L473">		        + valueDateTupels[nextAvailable].getValue()) / 2;</span>

<span class="fc" id="L475">		int localIndex = previousAvailable + 1;</span>
		/* Fill all values up to the next NaN with the calculated value. */
<span class="fc bfc" id="L477" title="All 2 branches covered.">		while (localIndex &lt; nextAvailable) {</span>
<span class="fc" id="L478">			valueDateTupels[localIndex].setValue(valueToBeSet);</span>
<span class="fc" id="L479">			localIndex++;</span>
		}
<span class="fc" id="L481">		return valueDateTupels;</span>
	}

	/**
	 * Fills the values at the beginning of the array. If the first valueDateTupel contains Double.NaN, its value will
	 * be set to match the next non-NaN-value. If the following values are also Double.NaN, iterate through the array
	 * until a value != Double.NaN is found.
	 *
	 * @param  valueDateTupels          {@code ValueDateTupel[]} An array of {@link ValueDateTupel} to be filled.
	 * @return                          {@code ValueDateTupel[]} The same array of {@link ValueDateTupel} but with
	 *                                  starting values filled.
	 * @throws IllegalArgumentException if the row only contains Double.NaN.
	 */
	private static ValueDateTupel[] fillStartingValues(ValueDateTupel[] valueDateTupels) {
<span class="fc" id="L495">		int localFieldIndex = 1;</span>
		/* Iterate through the array until a value != Double.NaN is found */
<span class="fc bfc" id="L497" title="All 2 branches covered.">		while (Double.isNaN(valueDateTupels[localFieldIndex].getValue())) {</span>
<span class="fc" id="L498">			localFieldIndex++;</span>
		}

		/*
		 * If only one value has to be set execution can continue with the next loop iteration
		 */
<span class="fc bfc" id="L504" title="All 2 branches covered.">		if (localFieldIndex == 1) {</span>
<span class="fc" id="L505">			valueDateTupels[localFieldIndex - 1].setValue(valueDateTupels[localFieldIndex].getValue());</span>
		}

		/*
		 * If multiple values have to be set iterate over them an fill them subsequently, starting from the last NaN
		 * before the first valid value.
		 */
<span class="fc bfc" id="L512" title="All 2 branches covered.">		while (localFieldIndex &gt;= 1) {</span>
<span class="fc" id="L513">			valueDateTupels[localFieldIndex - 1].setValue(valueDateTupels[localFieldIndex].getValue());</span>
<span class="fc" id="L514">			localFieldIndex--;</span>
		}

<span class="fc" id="L517">		return valueDateTupels;</span>
	}

	/**
	 * Get unique dates from an array of arrays of {@link ValueDateTupel}.
	 * 
	 * @param  valueDateTupels {@code ValueDateTupel[][]} The array of arrays of {@link ValueDateTupel} the get all
	 *                         unique dates from.
	 * @return                 {@code TreeSet&lt;LocalDateTime&gt;} A TreeSet of all unique dates.
	 */
	private static TreeSet&lt;LocalDateTime&gt; getUniqueDates(ValueDateTupel[][] valueDateTupels) {
<span class="fc" id="L528">		TreeSet&lt;LocalDateTime&gt; uniqueSortedDates = new TreeSet&lt;&gt;();</span>

		/* For each array in ValueDateTupels ... */
<span class="fc bfc" id="L531" title="All 2 branches covered.">		for (int rowIndex = 0; rowIndex &lt; valueDateTupels.length; rowIndex++) {</span>

			try {
<span class="fc" id="L534">				Validator.validateValues(valueDateTupels[rowIndex]);</span>
<span class="fc" id="L535">				Validator.validateDates(valueDateTupels[rowIndex]);</span>
<span class="fc" id="L536">			} catch (IllegalArgumentException e) {</span>
<span class="fc" id="L537">				throw new IllegalArgumentException(</span>
				        &quot;The array at position &quot; + rowIndex + &quot; does not meet specifications.&quot;, e);
<span class="fc" id="L539">			}</span>

			/* ... add all values into uniqueSortedDates */
<span class="fc" id="L542">			uniqueSortedDates.addAll(Arrays.asList(ValueDateTupel.getDates(valueDateTupels[rowIndex])));</span>
		}
<span class="fc" id="L544">		return uniqueSortedDates;</span>
	}

	/**
	 * Replace Double.NaN in a given row by real values values.
	 * 
	 * @param  valueDateTupels {@code ValueDateTupel[]} An array of {@link ValueDateTupel} to be enhanced.
	 * @return                 {@code ValueDateTupel[]} The same array of {@link ValueDateTupel} but with real values
	 *                         instead of Double.NaN.
	 */
	private static ValueDateTupel[] replaceNansByValues(ValueDateTupel[] valueDateTupels) {
		/*
		 * Loop over all dateTimes for each row to assess if they are Double.NaN.
		 */
<span class="fc bfc" id="L558" title="All 2 branches covered.">		for (int fieldIndex = 0; fieldIndex &lt; valueDateTupels.length; fieldIndex++) {</span>
			/*
			 * If the ValueDateTupel contains a value other than Double.NaN continue with the next iteration.
			 */
<span class="fc bfc" id="L562" title="All 2 branches covered.">			if (!Double.isNaN(valueDateTupels[fieldIndex].getValue()))</span>
<span class="fc" id="L563">				continue;</span>

			/*
			 * If the first valueDateTupel contains Double.NaN, its value will be set to match the next non-NaN-value.
			 * If the following values are also Double.NaN, iterate through the array until a value != Double.NaN is
			 * found.
			 */
<span class="fc bfc" id="L570" title="All 2 branches covered.">			if (fieldIndex == 0) {</span>
<span class="fc" id="L571">				valueDateTupels = fillStartingValues(valueDateTupels);</span>
<span class="fc" id="L572">				continue;</span>
			}

			/*
			 * The missing value will be set to average the values of its direct predecessor and successor.
			 * 
			 * If there are multiple values missing in a row, all of those will get the average value of the last
			 * position before and the first position after all missing values.
			 * 
			 * If all values until the last one are missing, all consecutive NaN values will be set to the last position
			 * before all NaNs.
			 */
<span class="fc" id="L584">			int limitIndex = fieldIndex;</span>

<span class="fc" id="L586">			double valueToBeSet = Double.NaN;</span>

<span class="fc bfc" id="L588" title="All 2 branches covered.">			while (Double.isNaN(valueDateTupels[limitIndex].getValue())) {</span>
<span class="fc" id="L589">				limitIndex++;</span>
				/*
				 * If there are no values in the remaining array set all values to be the last non-NaN, which is at
				 * fieldIndex-1.
				 */
<span class="fc bfc" id="L594" title="All 2 branches covered.">				if (limitIndex == valueDateTupels.length) {</span>
<span class="fc" id="L595">					limitIndex--;</span>
<span class="fc" id="L596">					valueToBeSet = valueDateTupels[fieldIndex - 1].getValue();</span>
<span class="fc" id="L597">					break;</span>
				}

			}

			/*
			 * If the value to be set has already been calculated then there is NaNs left in the array, no more real
			 * values, until the very last position. All remaining values can be set to this value then. After that the
			 * loop can be left.
			 */
<span class="fc bfc" id="L607" title="All 2 branches covered.">			if (!Double.isNaN(valueToBeSet)) {</span>
<span class="fc" id="L608">				int localIndex = fieldIndex;</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">				while (localIndex &lt; valueDateTupels.length) {</span>
<span class="fc" id="L610">					valueDateTupels[localIndex].setValue(valueToBeSet);</span>
<span class="fc" id="L611">					localIndex++;</span>
				}
				break;
			}

			/* Fill in a &quot;gap&quot; of Double.NaN-values */
<span class="fc" id="L617">			valueDateTupels = fillCenterValues(valueDateTupels, fieldIndex - 1, limitIndex);</span>

		}
<span class="fc" id="L620">		return valueDateTupels;</span>
	}

	/**
	 * ====================================================================== OVERRIDES
	 * ======================================================================
	 */

	/**
	 * A hash code for this ValueDateTupel.
	 */
	@GeneratedCode
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((date == null) ? 0 : date.hashCode());
		long temp;
		temp = Double.doubleToLongBits(value);
		result = prime * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));
		return result;
	}

	/**
	 * Checks if this ValueDateTupel is equal to another ValueDateTupel.
	 */
	@GeneratedCode
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		ValueDateTupel other = (ValueDateTupel) obj;
		if (date == null) {
			if (other.date != null)
				return false;
		} else if (!date.equals(other.date))
			return false;
		if (Double.doubleToLongBits(value) != Double.doubleToLongBits(other.value))
			return false;
		return true;
	}

	/**
	 * Outputs the fields of this ValueDateTupel as a {@code String}.
	 */
	@GeneratedCode
	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append(&quot;ValueDateTupel [value=&quot;);
		builder.append(value);
		builder.append(&quot;, date=&quot;);
		builder.append(date);
		builder.append(&quot;]&quot;);
		return builder.toString();
	}

	/**
	 * ====================================================================== GETTERS AND SETTERS
	 * ======================================================================
	 */

	/**
	 * Get the value of a {@link ValueDateTupel}
	 * 
	 * @return {@code double} value of the {@link ValueDateTupel}
	 */
	public double getValue() {
<span class="fc" id="L692">		return value;</span>
	}

	/**
	 * Set the value of a {@link ValueDateTupel}
	 * 
	 * @param value {@code double} value to be set
	 */
	public void setValue(double value) {
<span class="fc" id="L701">		this.value = value;</span>
<span class="fc" id="L702">	}</span>

	/**
	 * Get the date of a {@link ValueDateTupel}
	 * 
	 * @return {@link LocalDateTime} date for the {@link ValueDateTupel}
	 */
	public LocalDateTime getDate() {
<span class="fc" id="L710">		return date;</span>
	}

	/**
	 * Set the date for a {@link ValueDateTupel}
	 * 
	 * @param date {@link LocalDateTime} date to be set for the {@link ValueDateTupel}
	 */
	public void setDate(LocalDateTime date) {
<span class="fc" id="L719">		this.date = date;</span>
<span class="fc" id="L720">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>